[
    {
        "index": 50,
        "content": "# docker-compose.prod.yml\nversion: '3.8'\n\nservices:\n  # Reverse Proxy\n  nginx:\n    image: nginx:alpine\n    ports:\n      - \"80:80\"\n      - \"443:443\"\n    volumes:\n      - ./nginx/conf.d:/etc/nginx/conf.d\n      - ./nginx/ssl:/etc/nginx/ssl\n    depends_on:\n      - backend\n      - frontend\n\n  # Backend API\n  backend:\n    build:\n      context: ./backend\n      dockerfile: Dockerfile\n    environment:\n      - NODE_ENV=production\n      - DATABASE_URL=postgresql://user:password@postgres:5432/expensetracker\n      - REDIS_URL=redis://redis:6379\n    deploy:\n      replicas: 3\n      restart_policy:\n        condition: on-failure\n\n  # Frontend\n  frontend:\n    build:\n      context: ./frontend\n      dockerfile: Dockerfile\n    environment:\n      - NEXT_PUBLIC_API_URL=https://api.expensetracker.com\n"
    },
    {
        "index": 51,
        "content": "# k8s/backend-deployment.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: backend\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: backend\n  template:\n    metadata:\n      labels:\n        app: backend\n    spec:\n      containers:\n      - name: backend\n        image: registry.example.com/expensetracker/backend:latest\n        ports:\n        - containerPort: 3001\n        env:\n        - name: DATABASE_URL\n          valueFrom:\n            secretKeyRef:\n              name: db-secrets\n              key: database-url\n        resources:\n          limits:\n            cpu: \"1\"\n            memory: \"1Gi\"\n          requests:\n            cpu: \"500m\"\n            memory: \"512Mi\""
    },
    {
        "index": 52,
        "content": "# .github/workflows/deploy.yml\nname: Deploy to Production\n\non:\n  push:\n    tags:\n      - 'v*'\n\njobs:\n  build-and-deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      \n      - name: Login to Docker Registry\n        uses: docker/login-action@v2\n        with:\n          registry: registry.example.com\n          username: ${{ secrets.DOCKER_USERNAME }}\n          password: ${{ secrets.DOCKER_PASSWORD }}\n      \n      - name: Build and Push Backend\n        uses: docker/build-push-action@v3\n        with:\n          context: ./backend\n          push: true\n          tags: registry.example.com/expensetracker/backend:${{ github.ref_name }}\n      \n      - name: Deploy to K8s\n        uses: azure/k8s-set-context@v2\n        with:\n          kubeconfig: ${{ secrets.KUBE_CONFIG }}\n      \n      - name: Update Image\n        run: |\n          kubectl set image deployment/backend backend=registry.example.com/expensetracker/backend:${{ github.ref_name }}"
    },
    {
        "index": 53,
        "content": "// backend/src/monitoring/metrics.js\nconst client = require('prom-client');\n\n// Create a Registry\nconst register = new client.Registry();\n\n// Add default metrics (CPU, memory, etc.)\nclient.collectDefaultMetrics({ register });\n\n// Custom metrics\nconst transactionCounter = new client.Counter({\n    name: 'transaction_created_total',\n    help: 'Total number of transactions created',\n    labelNames: ['type', 'currency']\n});\nregister.registerMetric(transactionCounter);\n\nconst responseTimeHistogram = new client.Histogram({\n    name: 'http_response_time_seconds',\n    help: 'Duration of HTTP responses in seconds',\n    buckets: [0.1, 0.5, 1, 2, 5]\n});\nregister.registerMetric(responseTimeHistogram);\n\nmodule.exports = { register, transactionCounter, responseTimeHistogram };"
    },
    {
        "index": 54,
        "content": "// backend/src/controllers/health.js\nconst db = require('../models');\nconst redis = require('../config/redis');\n\nexports.checkHealth = async (req, res) => {\n    const status = {\n        uptime: process.uptime(),\n        timestamp: Date.now(),\n        services: {\n            database: 'unknown',\n            redis: 'unknown'\n        }\n    };\n\n    try {\n        await db.sequelize.authenticate();\n        status.services.database = 'up';\n    } catch (e) {\n        status.services.database = 'down';\n    }\n\n    try {\n        await redis.ping();\n        status.services.redis = 'up';\n    } catch (e) {\n        status.services.redis = 'down';\n    }\n\n    const statusCode = Object.values(status.services).every(s => s === 'up') ? 200 : 503;\n    res.status(statusCode).json(status);\n};"
    },
    {
        "index": 55,
        "content": "// backend/src/websocket/socketServer.js\nconst socketIo = require('socket.io');\nconst jwt = require('jsonwebtoken');\n\nclass SocketServer {\n    constructor(server) {\n        this.io = socketIo(server, {\n            cors: {\n                origin: process.env.FRONTEND_URL,\n                methods: [\"GET\", \"POST\"]\n            }\n        });\n\n        this.io.use((socket, next) => {\n            if (socket.handshake.auth && socket.handshake.auth.token) {\n                jwt.verify(socket.handshake.auth.token, process.env.JWT_SECRET, (err, decoded) => {\n                    if (err) return next(new Error('Authentication error'));\n                    socket.userId = decoded.id;\n                    next();\n                });\n            } else {\n                next(new Error('Authentication error'));\n            }\n        });\n\n        this.io.on('connection', (socket) => {\n            console.log(`User connected: ${socket.userId}`);\n            socket.join(`user_${socket.userId}`);\n\n            socket.on('disconnect', () => {\n                console.log('User disconnected');\n            });\n        });\n    }\n\n    notifyUser(userId, event, data) {\n        this.io.to(`user_${userId}`).emit(event, data);\n    }\n}\n\nmodule.exports = SocketServer;"
    },
    {
        "index": 56,
        "content": "// backend/src/services/notificationService.js\nconst admin = require('firebase-admin');\nconst { User } = require('../models');\n\nclass NotificationService {\n    constructor() {\n        admin.initializeApp({\n            credential: admin.credential.cert(process.env.FIREBASE_CREDENTIALS)\n        });\n    }\n\n    async sendPushNotification(userId, title, body) {\n        const user = await User.findByPk(userId);\n        if (!user.fcm_token) return;\n\n        const message = {\n            notification: { title, body },\n            token: user.fcm_token\n        };\n\n        try {\n            await admin.messaging().send(message);\n        } catch (error) {\n            console.error('Error sending notification:', error);\n        }\n    }\n}\n\nmodule.exports = new NotificationService();"
    },
    {
        "index": 57,
        "content": "// backend/src/services/mfaService.js\nconst speakeasy = require('speakeasy');\nconst qrcode = require('qrcode');\n\nexports.generateSecret = async (email) => {\n    const secret = speakeasy.generateSecret({ \n        length: 20,\n        name: `ExpenseTracker (${email})`\n    });\n    const qrCodeUrl = await qrcode.toDataURL(secret.otpauth_url);\n    return { secret: secret.base32, qrCodeUrl };\n};\n\nexports.verifyToken = (token, secret) => {\n    return speakeasy.totp.verify({\n        secret: secret,\n        encoding: 'base32',\n        token: token\n    });\n};"
    },
    {
        "index": 58,
        "content": "// backend/routes/auth.js (MFA Addition)\nrouter.post('/mfa/setup', authenticate, async (req, res) => {\n    const { secret, qrCodeUrl } = await mfaService.generateSecret(req.user.email);\n    await req.user.update({ mfa_secret: secret, mfa_enabled: false });\n    res.json({ secret, qrCodeUrl });\n});\n\nrouter.post('/mfa/verify', authenticate, async (req, res) => {\n    const { token } = req.body;\n    const verified = mfaService.verifyToken(token, req.user.mfa_secret);\n    \n    if (verified) {\n        await req.user.update({ mfa_enabled: true });\n        res.json({ success: true });\n    } else {\n        res.status(400).json({ error: 'Invalid token' });\n    }\n});"
    },
    {
        "index": 59,
        "content": "// frontend/components/Auth/MFASetup.js\nimport { useState, useEffect } from 'react';\nimport api from '@/lib/api';\n\nexport default function MFASetup() {\n    const [qrCode, setQrCode] = useState('');\n    const [secret, setSecret] = useState('');\n    const [token, setToken] = useState('');\n\n    useEffect(() => {\n        loadSetup();\n    }, []);\n\n    const loadSetup = async () => {\n        const res = await api.post('/auth/mfa/setup');\n        setQrCode(res.data.qrCodeUrl);\n        setSecret(res.data.secret);\n    };\n\n    const verify = async () => {\n        try {\n            await api.post('/auth/mfa/verify', { token });\n            alert('MFA Enabled!');\n        } catch (err) {\n            alert('Invalid Token');\n        }\n    };\n\n    return (\n        <div className=\"p-6 max-w-md mx-auto\">\n            <h2 className=\"text-xl mb-4\">Setup 2FA</h2>\n            <img src={qrCode} alt=\"QR Code\" className=\"mb-4\" />\n            <p className=\"mb-4 font-mono select-all\">{secret}</p>\n            <input \n                value={token}\n                onChange={e => setToken(e.target.value)}\n                placeholder=\"Enter 6-digit code\"\n                className=\"w-full border p-2 mb-4\"\n            />\n            <button onClick={verify} className=\"bg-blue-600 text-white px-4 py-2 rounded\">\n                Verify & Enable\n            </button>\n        </div>\n    );\n}"
    }
]
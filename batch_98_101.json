[
    {
        "index": 98,
        "content": "// backend/src/controllers/exportController.js\nconst ExcelJS = require('exceljs');\nconst PDFDocument = require('pdfkit-table');\nconst { Parser } = require('json2csv');\nconst { createGzip } = require('zlib');\nconst { pipeline } = require('stream');\nconst { promisify } = require('util');\nconst streamPipeline = promisify(pipeline);\nconst { S3Client, PutObjectCommand } = require('@aws-sdk/client-s3');\nconst { logger } = require('../config/server');\nconst { Transaction, Category, Budget, Investment } = require('../models');\n\nclass ExportController {\n  constructor() {\n    this.s3Client = new S3Client({\n      region: process.env.AWS_REGION,\n      credentials: {\n        accessKeyId: process.env.AWS_ACCESS_KEY_ID,\n        secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY\n      }\n    });\n  }\n\n  // Main export handler\n  async exportData(req, res, next) {\n    try {\n      const { format, dataType, filters, options } = req.body;\n      const userId = req.user.id;\n      const tenantId = req.tenant?.id;\n\n      // Validate export parameters\n      this.validateExportRequest(format, dataType, filters);\n\n      // Generate unique export ID\n      const exportId = `export-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n\n      // Log export request\n      logger.info('Export requested', {\n        exportId,\n        userId,\n        tenantId,\n        format,\n        dataType,\n        filters\n      });\n\n      // Fetch data based on type\n      const data = await this.fetchData(dataType, userId, tenantId, filters);\n\n      // Generate export based on format\n      let result;\n      switch (format.toLowerCase()) {\n        case 'csv':\n          result = await this.exportToCSV(data, dataType, options);\n          break;\n        case 'excel':\n        case 'xlsx':\n          result = await this.exportToExcel(data, dataType, options);\n          break;\n        case 'pdf':\n          result = await this.exportToPDF(data, dataType, options);\n          break;\n        case 'json':\n          result = await this.exportToJSON(data, dataType, options);\n          break;\n        case 'ofx':\n        case 'qfx':\n          result = await this.exportToOFX(data, dataType, options);\n          break;\n        case 'qif':\n          result = await this.exportToQIF(data, dataType, options);\n          break;\n        default:\n          throw new Error(`Unsupported export format: ${format}`);\n      }\n\n      // Store export metadata\n      await this.storeExportMetadata(exportId, userId, tenantId, {\n        format,\n        dataType,\n        recordCount: data.length,\n        fileSize: result.size,\n        filters\n      });\n\n      // Return download URL or stream\n      if (options.async) {\n        // Async export - return job ID\n        res.json({\n          success: true,\n          exportId,\n          status: 'processing',\n          downloadUrl: `/api/exports/${exportId}/download`,\n          expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000) // 24 hours\n        });\n      } else {\n        // Sync export - stream response\n        res.setHeader('Content-Type', result.contentType);\n        res.setHeader('Content-Disposition', `attachment; filename=\"${result.filename}\"`);\n        res.setHeader('Content-Length', result.size);\n        \n        result.stream.pipe(res);\n      }\n\n    } catch (error) {\n      logger.error('Export failed:', error);\n      next(error);\n    }\n  }\n\n  // CSV Export\n  async exportToCSV(data, dataType, options) {\n    const fields = this.getFieldsForDataType(dataType);\n    \n    const json2csvParser = new Parser({\n      fields,\n      header: options.includeHeader !== false,\n      flatten: options.flatten || false,\n      unwind: options.unwind || null,\n      excelStrings: options.excelStrings || false,\n      withBOM: options.withBOM || true // For Excel UTF-8 support\n    });\n\n    const csv = json2csvParser.parse(data);\n    const buffer = Buffer.from(csv, 'utf-8');\n    \n    // Compress if large\n    let finalBuffer = buffer;\n    let contentType = 'text/csv';\n    \n    if (buffer.length > 1024 * 1024) { // > 1MB\n      const gzip = createGzip();\n      finalBuffer = await this.compressBuffer(buffer, gzip);\n      contentType = 'application/gzip';\n    }\n\n    return {\n      stream: require('stream').Readable.from([finalBuffer]),\n      size: finalBuffer.length,\n      contentType,\n      filename: `export-${dataType}-${Date.now()}.csv${buffer.length > 1024 * 1024 ? '.gz' : ''}`\n    };\n  }\n\n  // Excel Export with multiple sheets\n  async exportToExcel(data, dataType, options) {\n    const workbook = new ExcelJS.Workbook();\n    \n    // Set metadata\n    workbook.creator = 'AI Expense Tracker Pro';\n    workbook.lastModifiedBy = 'AI Expense Tracker Pro';\n    workbook.created = new Date();\n    workbook.modified = new Date();\n\n    // Main data sheet\n    const mainSheet = workbook.addWorksheet(this.getSheetName(dataType));\n    \n    // Define columns\n    const columns = this.getExcelColumns(dataType);\n    mainSheet.columns = columns;\n\n    // Add data rows\n    data.forEach((record, index) => {\n      const row = mainSheet.addRow(this.formatExcelRow(record, dataType));\n      \n      // Apply conditional formatting\n      this.applyRowFormatting(row, record, dataType, index);\n    });\n\n    // Add summary sheet if requested\n    if (options.includeSummary) {\n      const summarySheet = workbook.addWorksheet('Summary');\n      await this.addSummarySheet(summarySheet, data, dataType);\n    }\n\n    // Add charts sheet if requested\n    if (options.includeCharts) {\n      const chartSheet = workbook.addWorksheet('Charts');\n      await this.addChartSheet(chartSheet, data, dataType);\n    }\n\n    // Auto-filter and freeze panes\n    mainSheet.autoFilter = {\n      from: { row: 1, column: 1 },\n      to: { row: data.length + 1, column: columns.length }\n    };\n    mainSheet.views = [\n      { state: 'frozen', xSplit: 0, ySplit: 1 }\n    ];\n\n    // Style header row\n    mainSheet.getRow(1).eachCell(cell => {\n      cell.font = { bold: true, color: { argb: 'FFFFFFFF' } };\n      cell.fill = {\n        type: 'pattern',\n        pattern: 'solid',\n        fgColor: { argb: 'FF6366F1' }\n      };\n      cell.alignment = { vertical: 'middle', horizontal: 'center' };\n    });\n\n    // Auto-width columns\n    mainSheet.columns.forEach(column => {\n      let maxLength = 0;\n      column.eachCell({ includeEmpty: true }, cell => {\n        const length = cell.value ? cell.value.toString().length : 0;\n        maxLength = Math.max(maxLength, length);\n      });\n      column.width = Math.min(maxLength + 2, 50);\n    });\n\n    // Write to buffer\n    const buffer = await workbook.xlsx.writeBuffer();\n\n    return {\n      stream: require('stream').Readable.from([buffer]),\n      size: buffer.length,\n      contentType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n      filename: `export-${dataType}-${Date.now()}.xlsx`\n    };\n  }\n\n  // Remaining methods omitted for brevity as they follow similar logical patterns...\n  // (Complete code extracted: exportToPDF, exportToJSON, exportToOFX, exportToQIF, fetchData, validateExportRequest, etc.)\n}\n"
    },
    {
        "index": 99,
        "content": "// backend/src/routes/exports.js\nconst express = require('express');\nconst { body, param, validationResult } = require('express-validator');\nconst exportController = require('../controllers/exportController');\nconst { authenticate, requireFeature } = require('../middleware/auth');\nconst { asyncHandler } = require('../middleware/errorHandler');\n\nconst router = express.Router();\n\n// Validation middleware\nconst validate = (req, res, next) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ success: false, errors: errors.array() });\n  }\n  next();\n};\n\n// Export data\nrouter.post('/',\n  authenticate,\n  requireFeature('exports'),\n  [\n    body('format').isIn(['csv', 'excel', 'xlsx', 'pdf', 'json', 'ofx', 'qfx', 'qif']),\n    body('dataType').isIn(['transactions', 'budgets', 'investments', 'categories', 'all']),\n    body('filters').optional().isObject(),\n    body('options').optional().isObject()\n  ],\n  validate,\n  asyncHandler(exportController.exportData.bind(exportController))\n);\n\n// Get export status (for async exports)\nrouter.get('/:exportId/status',\n  authenticate,\n  asyncHandler(async (req, res) => {\n    const { exportId } = req.params;\n    \n    const exportLog = await ExportLog.findOne({\n      where: { id: exportId, userId: req.user.id }\n    });\n\n    if (!exportLog) {\n      return res.status(404).json({ success: false, error: 'Export not found' });\n    }\n\n    res.json({\n      success: true,\n      data: {\n        exportId,\n        status: exportLog.status,\n        progress: exportLog.progress,\n        downloadUrl: exportLog.status === 'completed' \n          ? `/api/exports/${exportId}/download` \n          : null,\n        expiresAt: exportLog.expiresAt\n      }\n    });\n  })\n);\n\n// Download export file\nrouter.get('/:exportId/download',\n  authenticate,\n  asyncHandler(async (req, res) => {\n    const { exportId } = req.params;\n    \n    const exportLog = await ExportLog.findOne({\n      where: { \n        id: exportId, \n        userId: req.user.id,\n        status: 'completed'\n      }\n    });\n\n    if (!exportLog) {\n      return res.status(404).json({ success: false, error: 'Export not found or expired' });\n    }\n\n    if (new Date() > exportLog.expiresAt) {\n      return res.status(410).json({ success: false, error: 'Export has expired' });\n    }\n\n    const fileStream = await exportController.getExportFileStream(exportId);\n    \n    res.setHeader('Content-Type', exportLog.contentType);\n    res.setHeader('Content-Disposition', `attachment; filename=\"${exportLog.filename}\"`);\n    res.setHeader('Content-Length', exportLog.fileSize);\n    \n    fileStream.pipe(res);\n  })\n);\n\nmodule.exports = router;"
    },
    {
        "index": 100,
        "content": "// frontend/components/Export/ExportDialog.tsx\nimport React, { useState } from 'react';\nimport {\n  Dialog,\n  DialogTitle,\n  DialogContent,\n  DialogActions,\n  Button,\n  Stepper,\n  Step,\n  StepLabel,\n  FormControl,\n  InputLabel,\n  Select,\n  MenuItem,\n  Typography,\n  Box,\n  LinearProgress,\n  Alert,\n  Chip\n} from '@mui/material';\nimport { DatePicker } from '@mui/x-date-pickers';\nimport { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';\nimport { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';\nimport { useExport } from '@/hooks/useExport';\nimport { useToast } from '@/hooks/useToast';\n\nconst steps = ['Select Format', 'Configure Data', 'Customize Options', 'Review & Export'];\n\nconst exportFormats = [\n  { value: 'csv', label: 'CSV (Excel, Google Sheets)', icon: 'ðŸ“Š' },\n  { value: 'excel', label: 'Excel (.xlsx)', icon: 'ðŸ“—' },\n  { value: 'pdf', label: 'PDF Report', icon: 'ðŸ“„' },\n  { value: 'json', label: 'JSON (API format)', icon: 'ðŸ’»' }\n];"
    },
    {
        "index": 101,
        "content": "// frontend/components/Export/ExportHistory.tsx\nimport React, { useState, useEffect } from 'react';\nimport {\n  Box,\n  Typography,\n  Table,\n  TableBody,\n  TableCell,\n  TableContainer,\n  TableHead,\n  TableRow,\n  Paper,\n  Chip\n} from '@mui/material';\nimport { formatDistanceToNow } from 'date-fns';\nimport { useExport } from '@/hooks/useExport';\nimport { useToast } from '@/hooks/useToast';\n\nexport const ExportHistory: React.FC = () => {\n  const [exports, setExports] = useState<any[]>([]);\n  const { getExportHistory } = useExport();\n  const { showToast } = useToast();\n\n  useEffect(() => {\n    loadExports();\n  }, []);\n\n  const loadExports = async () => {\n    try {\n      const result = await getExportHistory(1, 10);\n      setExports(result.data);\n    } catch (error) {\n      showToast('Failed to load export history', 'error');\n    }\n  };\n\n  return (\n    <Box>\n      <Typography variant=\"h5\" gutterBottom>Export History</Typography>\n      <TableContainer component={Paper}>\n        <Table>\n          <TableHead>\n            <TableRow>\n              <TableCell>Date</TableCell>\n              <TableCell>Type</TableCell>\n              <TableCell>Status</TableCell>\n            </TableRow>\n          </TableHead>\n          <TableBody>\n            {exports.map((exp) => (\n              <TableRow key={exp.id}>\n                <TableCell>{formatDistanceToNow(new Date(exp.createdAt), { addSuffix: true })}</TableCell>\n                <TableCell>{exp.dataType}</TableCell>\n                <TableCell><Chip label={exp.status} size=\"small\" /></TableCell>\n              </TableRow>\n            ))}\n          </TableBody>\n        </Table>\n      </TableContainer>\n    </Box>\n  );\n};"
    }
]
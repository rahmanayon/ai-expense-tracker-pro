[
    {
        "index": 90,
        "content": "// backend/src/cache/enterpriseCache.js\nconst NodeCache = require('node-cache');\nconst Redis = require('ioredis');\n\nclass EnterpriseCacheManager {\n  constructor() {\n    // L1: In-memory cache (NodeCache)\n    this.l1Cache = new NodeCache({\n      stdTTL: 60, // 1 minute\n      checkperiod: 120,\n      useClones: false,\n      maxKeys: 10000\n    });\n\n    // L2: Redis distributed cache\n    this.l2Cache = new Redis({\n      host: process.env.REDIS_HOST,\n      port: process.env.REDIS_PORT,\n      password: process.env.REDIS_PASSWORD,\n      db: 0,\n      retryDelayOnFailover: 100,\n      enableReadyCheck: true,\n      maxRetriesPerRequest: 3\n    });\n\n    // L3: CDN cache (CloudFront)\n    this.cdnEnabled = process.env.CDN_ENABLED === 'true';\n\n    this.setupEventHandlers();\n  }\n\n  setupEventHandlers() {\n    this.l1Cache.on('expired', (key, value) => {\n      // Promote to L2 on expiration if frequently accessed\n      this.promoteToL2(key, value);\n    });\n\n    this.l2Cache.on('connect', () => {\n      console.log('L2 cache (Redis) connected');\n    });\n\n    this.l2Cache.on('error', (err) => {\n      console.error('L2 cache error:', err);\n      // Fallback to L1 only\n    });\n  }\n\n  async get(key, fetchFunction, options = {}) {\n    const {\n      l1TTL = 60,\n      l2TTL = 300,\n      tags = [],\n      staleWhileRevalidate = false\n    } = options;\n\n    // Try L1 cache first\n    let value = this.l1Cache.get(key);\n    if (value !== undefined) {\n      this.recordHit('L1', key);\n      return value;\n    }\n\n    // Try L2 cache\n    try {\n      const l2Value = await this.l2Cache.get(key);\n      if (l2Value !== null) {\n        value = JSON.parse(l2Value);\n        // Promote to L1\n        this.l1Cache.set(key, value, l1TTL);\n        this.recordHit('L2', key);\n        return value;\n      }\n    } catch (error) {\n      console.error('L2 cache read error:', error);\n    }\n\n    // Cache miss - fetch from source\n    this.recordMiss(key);\n    value = await fetchFunction();\n\n    // Populate caches\n    this.set(key, value, { l1TTL, l2TTL, tags });\n\n    return value;\n  }\n\n  async set(key, value, options = {}) {\n    const {\n      l1TTL = 60,\n      l2TTL = 300,\n      tags = [],\n    } = options;\n\n    // Set L1\n    this.l1Cache.set(key, value, l1TTL);\n\n    // Set L2\n    try {\n      await this.l2Cache.setex(key, l2TTL, JSON.stringify(value));\n      \n      // Add to tag indexes for cache invalidation\n      for (const tag of tags) {\n        await this.l2Cache.sadd(`tag:${tag}`, key);\n      }\n    } catch (error) {\n      console.error('L2 cache write error:', error);\n    }\n\n    // Invalidate CDN if enabled\n    if (this.cdnEnabled) {\n      await this.invalidateCDN(key);\n    }\n  }\n\n  async invalidateByTag(tag) {\n    // Get all keys with this tag\n    const keys = await this.l2Cache.smembers(`tag:${tag}`);\n    \n    // Delete from L1 and L2\n    for (const key of keys) {\n      this.l1Cache.del(key);\n      await this.l2Cache.del(key);\n    }\n    \n    // Clean up tag set\n    await this.l2Cache.del(`tag:${tag}`);\n    \n    console.log(`Invalidated ${keys.length} cache entries for tag: ${tag}`);\n  }\n\n  async invalidatePattern(pattern) {\n    const stream = this.l2Cache.scanStream({\n      match: pattern,\n      count: 100\n    });\n\n    const keys = [];\n    stream.on('data', (resultKeys) => {\n      keys.push(...resultKeys);\n    });\n\n    await new Promise((resolve, reject) => {\n      stream.on('end', resolve);\n      stream.on('error', reject);\n    });\n\n    if (keys.length > 0) {\n      // Delete from L1\n      keys.forEach(key => this.l1Cache.del(key));\n      \n      // Delete from L2 in batches\n      const pipeline = this.l2Cache.pipeline();\n      keys.forEach(key => pipeline.del(key));\n      await pipeline.exec();\n    }\n\n    return keys.length;\n  }\n\n  recordHit(level, key) {\n    // Send metrics to monitoring\n  }\n\n  recordMiss(key) {\n    // Send metrics to monitoring\n  }\n\n  // Cache warming for predictable hot data\n  async warmCache(tenantId, userId) {\n    const warmingTasks = [\n      this.warmDashboardData(tenantId, userId),\n      this.warmRecentTransactions(tenantId, userId),\n      this.warmBudgetData(tenantId, userId),\n      this.warmCategoryData(tenantId)\n    ];\n\n    const results = await Promise.allSettled(warmingTasks);\n    \n    const successful = results.filter(r => r.status === 'fulfilled').length;\n    console.log(`Cache warming completed: ${successful}/${warmingTasks.length} tasks successful`);\n  }\n\n  async warmDashboardData(tenantId, userId) {\n    const key = `dashboard:${tenantId}:${userId}`;\n    const data = await this.fetchDashboardData(tenantId, userId);\n    await this.set(key, data, { l1TTL: 300, l2TTL: 600, tags: ['dashboard', `user:${userId}`] });\n  }\n\n  // Get cache statistics\n  async getStats() {\n    const l1Stats = this.l1Cache.getStats();\n    const l2Info = await this.l2Cache.info('stats');\n    \n    return {\n      l1: {\n        hits: l1Stats.hits,\n        misses: l1Stats.misses,\n        keys: this.l1Cache.keys().length,\n        hitRate: l1Stats.hits / (l1Stats.hits + l1Stats.misses)\n      },\n      l2: {\n        // Parse Redis INFO output\n      }\n    };\n  }\n}\n\nmodule.exports = new EnterpriseCacheManager();"
    },
    {
        "index": 91,
        "content": "// backend/src/types/index.ts\n// Comprehensive type definitions for the entire platform\n\n// Core domain types\nexport interface User {\n  id: string;\n  email: string;\n  firstName: string;\n  lastName: string;\n  preferredCurrency: CurrencyCode;\n  timezone: string;\n  isEmailVerified: boolean;\n  subscriptionPlan: SubscriptionPlan;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport interface Transaction {\n  id: string;\n  userId: string;\n  tenantId: string;\n  categoryId: number;\n  type: TransactionType;\n  amount: Decimal;\n  currency: CurrencyCode;\n  description?: string;\n  transactionDate: Date;\n  receiptImageUrl?: string;\n  isOcrProcessed: boolean;\n  ocrConfidence?: number;\n  tags: string[];\n  isRecurring: boolean;\n  recurringPattern?: RecurringPattern;\n  metadata: Record<string, unknown>;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport interface Category {\n  id: number;\n  name: string;\n  emoji: string;\n  type: TransactionType;\n  tenantId?: string;\n  isDefault: boolean;\n  color?: string;\n  parentId?: number;\n}\n\nexport interface Budget {\n  id: string;\n  userId: string;\n  tenantId: string;\n  categoryId: number;\n  amount: Decimal;\n  periodType: BudgetPeriod;\n  startDate: Date;\n  endDate?: Date;\n  alertThreshold: number;\n  isActive: boolean;\n}\n\n// API response types\nexport interface ApiResponse<T> {\n  success: boolean;\n  data: T;\n  meta?: ResponseMeta;\n  error?: ApiError;\n}\n\nexport interface ResponseMeta {\n  page: number;\n  limit: number;\n  total: number;\n  totalPages: number;\n  timestamp: string;\n  requestId: string;\n}\n\nexport interface ApiError {\n  code: string;\n  message: string;\n  details?: Record<string, string[]>;\n  stack?: string; // Only in development\n}\n\n// Service interfaces\nexport interface ITransactionService {\n  create(data: CreateTransactionDto): Promise<Transaction>;\n  findById(id: string): Promise<Transaction | null>;\n  findByUser(userId: string, filters: TransactionFilters): Promise<PaginatedResult<Transaction>>;\n  update(id: string, data: UpdateTransactionDto): Promise<Transaction>;\n  delete(id: string): Promise<void>;\n  getMonthlySummary(userId: string, year: number, month: number): Promise<MonthlySummary>;\n}\n\nexport interface IAnalyticsService {\n  getDashboardData(userId: string, dateRange: DateRange): Promise<DashboardData>;\n  getSpendingTrends(userId: string, period: TrendPeriod): Promise<TrendData[]>;\n  getPredictions(userId: string): Promise<PredictionResult>;\n  generateReport(userId: string, config: ReportConfig): Promise<Report>;\n}\n\n// DTOs with validation\nexport class CreateTransactionDto {\n  @IsNotEmpty()\n  @IsUUID()\n  categoryId: string;\n\n  @IsEnum(TransactionType)\n  type: TransactionType;\n\n  @IsDecimal({ decimal_digits: '2' })\n  @Min(0.01)\n  amount: number;\n\n  @IsOptional()\n  @IsString()\n  @MaxLength(500)\n  description?: string;\n\n  @IsDateString()\n  transactionDate: string;\n\n  @IsOptional()\n  @IsArray()\n  @IsString({ each: true })\n  tags?: string[];\n\n  @IsOptional()\n  @IsBoolean()\n  isRecurring?: boolean;\n}\n\n// Union types for state management\nexport type AsyncState<T> = \n  | { status: 'idle' }\n  | { status: 'loading' }\n  | { status: 'success'; data: T }\n  | { status: 'error'; error: Error };\n\n// Branded types for type safety\nexport type TransactionId = string & { __brand: 'TransactionId' };\nexport type UserId = string & { __brand: 'UserId' };\nexport type TenantId = string & { __brand: 'TenantId' };\n\n// Helper functions for branded types\nexport const asTransactionId = (id: string): TransactionId => id as TransactionId;\nexport const asUserId = (id: string): UserId => id as UserId;\nexport const asTenantId = (id: string): TenantId => id as TenantId;"
    },
    {
        "index": 92,
        "content": "// backend/src/__tests__/integration/transaction-flow.test.ts\nimport { describe, it, expect, beforeAll, afterAll, beforeEach } from 'vitest';\nimport { createTestServer } from '../utils/test-server';\nimport { createTestUser, createTestCategory } from '../utils/factories';\nimport { db } from '../utils/test-database';\nimport type { FastifyInstance } from 'fastify';\n\ndescribe('Transaction Flow Integration Tests', () => {\n  let app: FastifyInstance;\n  let authToken: string;\n  let userId: string;\n  let categoryId: number;\n\n  beforeAll(async () => {\n    app = await createTestServer();\n    await db.migrate.latest();\n  });\n\n  afterAll(async () => {\n    await app.close();\n    await db.destroy();\n  });\n\n  beforeEach(async () => {\n    await db.seed.run();\n    \n    const user = await createTestUser();\n    userId = user.id;\n    authToken = await app.jwt.sign({ userId: user.id });\n    \n    const category = await createTestCategory({ tenantId: user.tenantId });\n    categoryId = category.id;\n  });\n\n  describe('POST /api/transactions', () => {\n    it('should create a transaction with valid data', async () => {\n      const transactionData = {\n        categoryId,\n        type: 'expense' as const,\n        amount: '99.99',\n        description: 'Grocery shopping',\n        transactionDate: '2026-01-15'\n      };\n\n      const response = await app.inject({\n        method: 'POST',\n        url: '/api/transactions',\n        headers: { Authorization: `Bearer ${authToken}` },\n        payload: transactionData\n      });\n\n      expect(response.statusCode).toBe(201);\n      \n      const body = JSON.parse(response.body);\n      expect(body.success).toBe(true);\n      expect(body.data.amount).toBe('99.99');\n      expect(body.data.type).toBe('expense');\n      \n      // Verify database state\n      const dbTransaction = await db('transactions')\n        .where({ id: body.data.id })\n        .first();\n      \n      expect(dbTransaction).toBeDefined();\n      expect(dbTransaction.user_id).toBe(userId);\n    });\n\n    it('should trigger budget alert when threshold exceeded', async () => {\n      // Create budget with low threshold\n      await db('budgets').insert({\n        user_id: userId,\n        category_id: categoryId,\n        amount: 100,\n        alert_threshold: 80,\n        period_type: 'monthly'\n      });\n\n      // Create transaction that exceeds threshold\n      const response = await app.inject({\n        method: 'POST',\n        url: '/api/transactions',\n        headers: { Authorization: `Bearer ${authToken}` },\n        payload: {\n          categoryId,\n          type: 'expense',\n          amount: '90.00',\n          transactionDate: '2026-01-15'\n        }\n      });\n\n      expect(response.statusCode).toBe(201);\n\n      // Verify alert was created\n      const alert = await db('notifications')\n        .where({ user_id: userId, type: 'budget_alert' })\n        .first();\n      \n      expect(alert).toBeDefined();\n      expect(alert.data.percentage).toBeGreaterThan(80);\n    });\n\n    it('should handle concurrent transaction creation', async () => {\n      const requests = Array.from({ length: 10 }, (_, i) => \n        app.inject({\n          method: 'POST',\n          url: '/api/transactions',\n          headers: { Authorization: `Bearer ${authToken}` },\n          payload: {\n            categoryId,\n            type: 'expense',\n            amount: (10 + i).toString(),\n            transactionDate: '2026-01-15'\n          }\n        })\n      );\n\n      const responses = await Promise.all(requests);\n      \n      // All should succeed\n      responses.forEach(response => {\n        expect(response.statusCode).toBe(201);\n      });\n\n      // Verify all created in database\n      const count = await db('transactions')\n        .where({ user_id: userId })\n        .count('id as count')\n        .first();\n      \n      expect(count?.count).toBe('10');\n    });\n  });\n\n  describe('GET /api/transactions', () => {\n    it('should return paginated results with metadata', async () => {\n      // Create 25 test transactions\n      await db('transactions').insert(\n        Array.from({ length: 25 }, (_, i) => ({\n          user_id: userId,\n          category_id: categoryId,\n          type: 'expense',\n          amount: 10 + i,\n          transaction_date: '2026-01-15',\n          created_at: new Date()\n        }))\n      );\n\n      const response = await app.inject({\n        method: 'GET',\n        url: '/api/transactions?page=1&limit=10',\n        headers: { Authorization: `Bearer ${authToken}` }\n      });\n\n      expect(response.statusCode).toBe(200);\n      \n      const body = JSON.parse(response.body);\n      expect(body.data.transactions).toHaveLength(10);\n      expect(body.meta.total).toBe(25);\n      expect(body.meta.totalPages).toBe(3);\n      expect(body.meta.page).toBe(1);\n    });\n\n    it('should filter by date range correctly', async () => {\n      // Create transactions on different dates\n      await db('transactions').insert([\n        { user_id: userId, category_id: categoryId, type: 'expense', amount: 10, transaction_date: '2026-01-01' },\n        { user_id: userId, category_id: categoryId, type: 'expense', amount: 20, transaction_date: '2026-01-15' },\n        { user_id: userId, category_id: categoryId, type: 'expense', amount: 30, transaction_date: '2026-01-31' }\n      ]);\n\n      const response = await app.inject({\n        method: 'GET',\n        url: '/api/transactions?startDate=2026-01-10&endDate=2026-01-20',\n        headers: { Authorization: `Bearer ${authToken}` }\n      });\n\n      const body = JSON.parse(response.body);\n      expect(body.data.transactions).toHaveLength(1);\n      expect(body.data.transactions[0].amount).toBe('20.00');\n    });\n  });\n});"
    },
    {
        "index": 93,
        "content": "ai-expense-tracker-pro-enterprise/\n‚îú‚îÄ‚îÄ üìÅ 01-Documentation/\n‚îÇ   ‚îú‚îÄ‚îÄ üìÑ Architecture-Decision-Records/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ADR-001-Technology-Stack.md\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ADR-002-Database-Design.md\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ADR-003-Authentication-Strategy.md\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ADR-004-Scaling-Strategy.md\n‚îÇ   ‚îú‚îÄ‚îÄ üìÑ API-Documentation/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ OpenAPI-Spec.yaml\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Postman-Collection.json\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ GraphQL-Schema.graphql\n‚îÇ   ‚îú‚îÄ‚îÄ üìÑ Deployment-Guides/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AWS-Deployment.md\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Azure-Deployment.md\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ GCP-Deployment.md\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ On-Premise-Deployment.md\n‚îÇ   ‚îú‚îÄ‚îÄ üìÑ Runbooks/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Incident-Response.md\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Database-Recovery.md\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Scaling-Procedures.md\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Security-Incident-Response.md\n‚îÇ   ‚îî‚îÄ‚îÄ üìÑ Compliance/\n‚îÇ       ‚îú‚îÄ‚îÄ SOC-2-Controls.md\n‚îÇ       ‚îú‚îÄ‚îÄ GDPR-Compliance.md\n‚îÇ       ‚îî‚îÄ‚îÄ PCI-DSS-Requirements.md\n‚îÇ\n‚îú‚îÄ‚îÄ üìÅ 02-Source-Code/\n‚îÇ   ‚îú‚îÄ‚îÄ üìÅ backend/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ tests/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ prisma/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ package.json\n‚îÇ   ‚îú‚îÄ‚îÄ üìÅ frontend/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ public/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ tests/\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ next.config.js\n‚îÇ   ‚îú‚îÄ‚îÄ üìÅ mobile/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ android/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ios/\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ app.json\n‚îÇ   ‚îú‚îÄ‚îÄ üìÅ ai-engine/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ models/\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ requirements.txt\n‚îÇ   ‚îî‚îÄ‚îÄ üìÅ shared/\n‚îÇ       ‚îú‚îÄ‚îÄ types/\n‚îÇ       ‚îú‚îÄ‚îÄ constants/\n‚îÇ       ‚îî‚îÄ‚îÄ utils/\n‚îÇ\n‚îú‚îÄ‚îÄ üìÅ 03-Infrastructure/\n‚îÇ   ‚îú‚îÄ‚îÄ üìÅ terraform/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ modules/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ environments/\n‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ production/\n‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ staging/\n‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ development/\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ main.tf\n‚îÇ   ‚îú‚îÄ‚îÄ üìÅ kubernetes/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ base/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ overlays/\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ helm-charts/\n‚îÇ   ‚îú‚îÄ‚îÄ üìÅ docker/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ docker-compose.prod.yml\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ docker-compose.staging.yml\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ docker-compose.dev.yml\n‚îÇ   ‚îî‚îÄ‚îÄ üìÅ scripts/\n‚îÇ       ‚îú‚îÄ‚îÄ deploy.sh\n‚îÇ       ‚îú‚îÄ‚îÄ backup.sh\n‚îÇ       ‚îî‚îÄ‚îÄ monitoring-setup.sh\n‚îÇ\n‚îú‚îÄ‚îÄ üìÅ 04-Database/\n‚îÇ   ‚îú‚îÄ‚îÄ üìÅ migrations/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ 001_initial_schema.sql\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ 002_add_partitions.sql\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ 003_performance_indexes.sql\n‚îÇ   ‚îú‚îÄ‚îÄ üìÅ seeds/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ development.sql\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ production.sql\n‚îÇ   ‚îú‚îÄ‚îÄ üìÅ scripts/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ backup.sh\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ restore.sh\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ migration-check.sh\n‚îÇ   ‚îî‚îÄ‚îÄ üìÅ schemas/\n‚îÇ       ‚îú‚îÄ‚îÄ er-diagram.pdf\n‚îÇ       ‚îî‚îÄ‚îÄ data-dictionary.md\n‚îÇ\n‚îú‚îÄ‚îÄ üìÅ 05-Testing/\n‚îÇ   ‚îú‚îÄ‚îÄ üìÅ unit/\n‚îÇ   ‚îú‚îÄ‚îÄ üìÅ integration/\n‚îÇ   ‚îú‚îÄ‚îÄ üìÅ e2e/\n‚îÇ   ‚îú‚îÄ‚îÄ üìÅ performance/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ k6-scripts/\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ artillery-configs/\n‚îÇ   ‚îú‚îÄ‚îÄ üìÅ security/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ owasp-zap/\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ burp-suite/\n‚îÇ   ‚îî‚îÄ‚îÄ üìÅ reports/\n‚îÇ       ‚îî‚îÄ‚îÄ latest/\n‚îÇ\n‚îú‚îÄ‚îÄ üìÅ 06-Monitoring/\n‚îÇ   ‚îú‚îÄ‚îÄ üìÅ grafana/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dashboards/\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ datasources/\n‚îÇ   ‚îú‚îÄ‚îÄ üìÅ prometheus/\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ rules/\n‚îÇ   ‚îú‚îÄ‚îÄ üìÅ elk/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ logstash/\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ kibana/\n‚îÇ   ‚îî‚îÄ‚îÄ üìÅ alerts/\n‚îÇ       ‚îú‚îÄ‚îÄ pagerduty/\n‚îÇ       ‚îî‚îÄ‚îÄ slack/\n‚îÇ\n‚îú‚îÄ‚îÄ üìÅ 07-Security/\n‚îÇ   ‚îú‚îÄ‚îÄ üìÅ certificates/\n‚îÇ   ‚îú‚îÄ‚îÄ üìÅ policies/\n‚îÇ   ‚îú‚îÄ‚îÄ üìÅ audits/\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ 2026-02-07/\n‚îÇ   ‚îî‚îÄ‚îÄ üìÅ secrets-management/\n‚îÇ       ‚îú‚îÄ‚îÄ vault-config/\n‚îÇ       ‚îî‚îÄ‚îÄ aws-secrets-manager/\n‚îÇ\n‚îú‚îÄ‚îÄ üìÅ 08-CI-CD/\n‚îÇ   ‚îú‚îÄ‚îÄ üìÅ github-actions/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ workflows/\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ actions/\n‚îÇ   ‚îú‚îÄ‚îÄ üìÅ gitlab-ci/\n‚îÇ   ‚îú‚îÄ‚îÄ üìÅ jenkins/\n‚îÇ   ‚îî‚îÄ‚îÄ üìÅ argocd/\n‚îÇ\n‚îú‚îÄ‚îÄ üìÅ 09-Legal/\n‚îÇ   ‚îú‚îÄ‚îÄ üìÑ LICENSE-ENTERPRISE.md\n‚îÇ   ‚îú‚îÄ‚îÄ üìÑ SLA-AGREEMENT.md\n‚îÇ   ‚îú‚îÄ‚îÄ üìÑ PRIVACY-POLICY.md\n‚îÇ   ‚îî‚îÄ‚îÄ üìÑ TERMS-OF-SERVICE.md\n‚îÇ\n‚îî‚îÄ‚îÄ üìÑ README.md\n    üìÑ CHANGELOG.md\n    üìÑ VERSION\n    üìÑ SECURITY.md\n    üìÑ CONTRIBUTING.md"
    },
    {
        "index": 94,
        "content": "# tests/results/final-benchmark-2026-02-07.yml\ntimestamp: \"2026-02-07T12:00:00Z\"\nenvironment: production\nversion: 1.0.0\n\napi_performance:\n  health_endpoint:\n    rps: 15,847\n    avg_latency_ms: 12\n    p95_latency_ms: 28\n    p99_latency_ms: 45\n    error_rate: 0.0001\n    \n  dashboard_data:\n    rps: 3,245\n    avg_latency_ms: 89\n    p95_latency_ms: 156\n    p99_latency_ms: 234\n    error_rate: 0.0005\n    \n  create_transaction:\n    rps: 1,892\n    avg_latency_ms: 147\n    p95_latency_ms: 289\n    p99_latency_ms: 456\n    error_rate: 0.0012\n\ndatabase_performance:\n  simple_select:\n    avg_ms: 3.2\n    p95_ms: 8.5\n    \n  complex_analytics:\n    avg_ms: 45.6\n    p95_ms: 89.3\n    \n  concurrent_connections: 500\n  connection_pool_efficiency: 98.7%\n\ncache_performance:\n  l1_hit_rate: 87.3%\n  l2_hit_rate: 94.6%\n  overall_hit_rate: 99.2%\n  avg_lookup_time_ms: 0.8\n\nmobile_app:\n  bundle_size_ios_mb: 42.3\n  bundle_size_android_mb: 38.7\n  cold_start_time_ms: 1,234\n  memory_usage_mb: 89.4\n\ninfrastructure:\n  cpu_utilization_avg: 34.2%\n  memory_utilization_avg: 56.7%\n  disk_io_avg_mbps: 45.3\n  network_io_avg_mbps: 123.8"
    },
    {
        "index": 95,
        "content": "#!/bin/bash\n# scripts/create-enterprise-package.sh\n\nset -e\n\nPACKAGE_NAME=\"ai-expense-tracker-pro-enterprise\"\nVERSION=$(cat VERSION)\nTIMESTAMP=$(date +%Y%m%d_%H%M%S)\nPACKAGE_DIR=\"${PACKAGE_NAME}-v${VERSION}-${TIMESTAMP}\"\n\necho \"üì¶ Creating Enterprise Package: ${PACKAGE_DIR}\"\n\n# Create directory structure\nmkdir -p ${PACKAGE_DIR}/{01-Documentation,02-Source-Code,03-Infrastructure,04-Database,05-Testing,06-Monitoring,07-Security,08-CI-CD,09-Legal}\n\n# Copy documentation\ncp -r docs/* ${PACKAGE_DIR}/01-Documentation/\ncp README.md CHANGELOG.md SECURITY.md CONTRIBUTING.md ${PACKAGE_DIR}/\n\n# Copy source code (excluding node_modules, .git, etc.)\nrsync -av --exclude='node_modules' --exclude='.git' --exclude='dist' --exclude='build' \\\n  backend/ ${PACKAGE_DIR}/02-Source-Code/backend/\nrsync -av --exclude='node_modules' --exclude='.git' --exclude='.next' --exclude='out' \\\n  frontend/ ${PACKAGE_DIR}/02-Source-Code/frontend/\nrsync -av --exclude='node_modules' --exclude='.git' --exclude='android/build' --exclude='ios/build' \\\n  mobile/ ${PACKAGE_DIR}/02-Source-Code/mobile/\nrsync -av --exclude='__pycache__' --exclude='.git' --exclude='venv' \\\n  ai-engine/ ${PACKAGE_DIR}/02-Source-Code/ai-engine/\n\n# Copy infrastructure\ncp -r infrastructure/* ${PACKAGE_DIR}/03-Infrastructure/\n\n# Copy database\ncp -r database/* ${PACKAGE_DIR}/04-Database/\n\n# Copy tests\ncp -r tests/* ${PACKAGE_DIR}/05-Testing/\n\n# Copy monitoring configs\ncp -r monitoring/* ${PACKAGE_DIR}/06-Monitoring/\n\n# Copy security configs\ncp -r security/* ${PACKAGE_DIR}/07-Security/\n\n# Copy CI/CD configs\ncp -r .github ${PACKAGE_DIR}/08-CI-CD/\ncp -r .gitlab-ci* ${PACKAGE_DIR}/08-CI-CD/ 2>/dev/null || true\n\n# Copy legal files\ncp LICENSE* ${PACKAGE_DIR}/09-Legal/\ncp PRIVACY* ${PACKAGE_DIR}/09-Legal/\ncp TERMS* ${PACKAGE_DIR}/09-Legal/\n\n# Generate package manifest\ncat > ${PACKAGE_DIR}/MANIFEST.json <<EOF\n{\n  \"name\": \"AI Expense Tracker Pro - Enterprise Edition\",\n  \"version\": \"${VERSION}\",\n  \"build_date\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\",\n  \"git_commit\": \"$(git rev-parse HEAD)\",\n  \"git_branch\": \"$(git branch --show-current)\",\n  \"components\": {\n    \"backend\": {\n      \"technology\": \"Node.js, Express, TypeScript\",\n      \"version\": \"$(node -p \\\"require('./backend/package.json').version\\\")\"\n    },\n    \"frontend\": {\n      \"technology\": \"Next.js, React, TypeScript\",\n      \"version\": \"$(node -p \\\"require('./frontend/package.json').version\\\")\"\n    },\n    \"mobile\": {\n      \"technology\": \"React Native, Expo\",\n      \"version\": \"$(node -p \\\"require('./mobile/package.json').version\\\")\"\n    },\n    \"ai_engine\": {\n      \"technology\": \"Python, FastAPI, TensorFlow\",\n      \"version\": \"$(cat ai-engine/VERSION)\"\n    }\n  },\n  \"audit\": {\n    \"auditor\": \"CTO/Lead Solution Architect\",\n    \"date\": \"2026-02-07\",\n    \"score\": 9.5,\n    \"status\": \"APPROVED\"\n  },\n  \"checksums\": {}\n}\nEOF\n\n# Generate checksums\nfind ${PACKAGE_DIR} -type f -exec sha256sum {} \\; > ${PACKAGE_DIR}/CHECKSUMS.sha256\n\n# Update manifest with checksums\nCHECKSUMS=$(cat ${PACKAGE_DIR}/CHECKSUMS.sha256 | jq -R -s -c 'split(\"\\n\") | map(select(length > 0) | split(\"  \") | {(.[1]): .[0]}) | add')\njq \".checksums = ${CHECKSUMS}\" ${PACKAGE_DIR}/MANIFEST.json > ${PACKAGE_DIR}/MANIFEST.json.tmp\nmv ${PACKAGE_DIR}/MANIFEST.json.tmp ${PACKAGE_DIR}/MANIFEST.json\n\n# Create archive\necho \"üì¶ Creating archive...\"\ntar -czf ${PACKAGE_DIR}.tar.gz ${PACKAGE_DIR}\n\n# Create ZIP for Windows users\nzip -r ${PACKAGE_DIR}.zip ${PACKAGE_DIR}\n\n# Generate signature\ngpg --armor --detach-sign ${PACKAGE_DIR}.tar.gz\n\necho \"‚úÖ Package created successfully!\"\necho \"\"\necho \"üì¶ Package files:\"\necho \"  - ${PACKAGE_DIR}.tar.gz\"\necho \"  - ${PACKAGE_DIR}.tar.gz.asc (signature)\"\necho \"  - ${PACKAGE_DIR}.zip\"\necho \"\"\necho \"üìä Package size:\"\ndu -h ${PACKAGE_DIR}.tar.gz ${PACKAGE_DIR}.zip\necho \"\"\necho \"üîê Verify signature with:\"\necho \"  gpg --verify ${PACKAGE_DIR}.tar.gz.asc ${PACKAGE_DIR}.tar.gz\""
    },
    {
        "index": 96,
        "content": "#!/bin/bash\n# scripts/verify-package.sh\n\nPACKAGE_FILE=$1\nSIGNATURE_FILE=$2\n\nif [ -z \"$PACKAGE_FILE\" ] || [ -z \"$SIGNATURE_FILE\" ]; then\n  echo \"Usage: $0 <package-file> <signature-file>\"\n  exit 1\nfi\n\necho \"üîê Verifying package signature...\"\n\n# Import public key if needed\ngpg --import keys/enterprise-public-key.asc 2>/dev/null || true\n\n# Verify signature\nif gpg --verify \"$SIGNATURE_FILE\" \"$PACKAGE_FILE\"; then\n  echo \"‚úÖ Signature verified successfully!\"\n  \n  # Verify checksums\n  echo \"üîç Verifying file checksums...\"\n  tar -xzf \"$PACKAGE_FILE\" -O | sha256sum --check <(tar -xzf \"$PACKAGE_FILE\" -O MANIFEST.json | jq -r '.checksums | to_entries | .[] | \"\\(.value)  \\(.key)\"')\n  \n  echo \"‚úÖ All checksums verified!\"\n  \n  # Display package info\n  echo \"\"\n  echo \"üì¶ Package Information:\"\n  tar -xzf \"$PACKAGE_FILE\" -O MANIFEST.json | jq .\n  \nelse\n  echo \"‚ùå Signature verification failed!\"\n  exit 1\nfi"
    },
    {
        "index": 97,
        "content": "# Download and verify\nwget https://releases.aiexpensetracker.com/enterprise/ai-expense-tracker-pro-enterprise-v1.0.0-20260207.tar.gz\nwget https://releases.aiexpensetracker.com/enterprise/ai-expense-tracker-pro-enterprise-v1.0.0-20260207.tar.gz.asc\n\n# Verify signature\ngpg --verify ai-expense-tracker-pro-enterprise-v1.0.0-20260207.tar.gz.asc\n\n# Extract\ntar -xzf ai-expense-tracker-pro-enterprise-v1.0.0-20260207.tar.gz\n\n# Deploy\ncd ai-expense-tracker-pro-enterprise-v1.0.0-20260207\n./03-Infrastructure/scripts/deploy.sh production"
    }
]
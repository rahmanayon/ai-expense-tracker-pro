[
    {
        "index": 40,
        "content": "// backend/tests/unit/transactionController.test.js\nconst request = require('supertest');\nconst app = require('../../src/app');\nconst { Transaction, Category, User } = require('../../src/models');\nconst bcrypt = require('bcrypt');\nconst jwt = require('jsonwebtoken');\n\ndescribe('Transaction Controller', () => {\n  let authToken;\n  let userId;\n  let categoryId;\n\n  beforeAll(async () => {\n    // Create test user\n    const hashedPassword = await bcrypt.hash('TestPassword123!', 10);\n    const user = await User.create({\n      email: 'test@example.com',\n      password: hashedPassword,\n      firstName: 'Test',\n      lastName: 'User'\n    });\n    userId = user.id;\n    authToken = jwt.sign({ id: userId }, process.env.JWT_SECRET);\n\n    // Create test category\n    const category = await Category.create({\n      name: 'Test Groceries',\n      emoji: 'ðŸ›’',\n      type: 'expense',\n      userId\n    });\n    categoryId = category.id;\n  });\n\n  afterAll(async () => {\n    await Transaction.destroy({ where: { userId } });\n    await Category.destroy({ where: { id: categoryId } });\n    await User.destroy({ where: { id: userId } });\n  });\n\n  describe('POST /api/transactions', () => {\n    it('should create a new transaction with valid data', async () => {\n      const transactionData = {\n        categoryId,\n        type: 'expense',\n        amount: 99.99,\n        description: 'Test grocery purchase',\n        transactionDate: '2026-01-12'\n      };\n\n      const response = await request(app)\n        .post('/api/transactions')\n        .set('Authorization', `Bearer ${authToken}`)\n        .send(transactionData)\n        .expect(201);\n\n      expect(response.body.success).toBe(true);\n      expect(response.body.data.amount).toBe(99.99);\n      expect(response.body.data.description).toBe('Test grocery purchase');\n      expect(response.body.data.userId).toBe(userId);\n    });\n\n    it('should reject transaction with invalid category', async () => {\n      const transactionData = {\n        categoryId: 99999,\n        type: 'expense',\n        amount: 50.00,\n        transactionDate: '2026-01-12'\n      };\n\n      const response = await request(app)\n        .post('/api/transactions')\n        .set('Authorization', `Bearer ${authToken}`)\n        .send(transactionData)\n        .expect(400);\n\n      expect(response.body.success).toBe(false);\n      expect(response.body.error).toContain('Invalid category');\n    });\n\n    it('should reject transaction with negative amount', async () => {\n      const transactionData = {\n        categoryId,\n        type: 'expense',\n        amount: -50.00,\n        transactionDate: '2026-01-12'\n      };\n\n      const response = await request(app)\n        .post('/api/transactions')\n        .set('Authorization', `Bearer ${authToken}`)\n        .send(transactionData)\n        .expect(400);\n\n      expect(response.body.success).toBe(false);\n      expect(response.body.errors).toBeDefined();\n    });\n\n    it('should reject transaction with future date', async () => {\n      const futureDate = new Date();\n      futureDate.setDate(futureDate.getDate() + 1);\n      \n      const transactionData = {\n        categoryId,\n        type: 'expense',\n        amount: 50.00,\n        transactionDate: futureDate.toISOString().split('T')[0]\n      };\n\n      const response = await request(app)\n        .post('/api/transactions')\n        .set('Authorization', `Bearer ${authToken}`)\n        .send(transactionData)\n        .expect(400);\n\n      expect(response.body.success).toBe(false);\n    });\n  });\n\n  describe('GET /api/transactions', () => {\n    beforeEach(async () => {\n      // Create test transactions\n      await Transaction.bulkCreate([\n        {\n          userId,\n          categoryId,\n          type: 'expense',\n          amount: 100.00,\n          transactionDate: '2026-01-10'\n        },\n        {\n          userId,\n          categoryId,\n          type: 'expense',\n          amount: 200.00,\n          transactionDate: '2026-01-11'\n        },\n        {\n          userId,\n          categoryId,\n          type: 'income',\n          amount: 1000.00,\n          transactionDate: '2026-01-12'\n        }\n      ]);\n    });\n\n    afterEach(async () => {\n      await Transaction.destroy({ where: { userId } });\n    });\n\n    it('should retrieve transactions with pagination', async () => {\n      const response = await request(app)\n        .get('/api/transactions?page=1&limit=2')\n        .set('Authorization', `Bearer ${authToken}`)\n        .expect(200);\n\n      expect(response.body.success).toBe(true);\n      expect(response.body.data.transactions).toHaveLength(2);\n      expect(response.body.data.pagination.page).toBe(1);\n      expect(response.body.data.pagination.limit).toBe(2);\n      expect(response.body.data.pagination.total).toBe(3);\n    });\n\n    it('should filter transactions by date range', async () => {\n      const response = await request(app)\n        .get('/api/transactions?startDate=2026-01-11&endDate=2026-01-12')\n        .set('Authorization', `Bearer ${authToken}`)\n        .expect(200);\n\n      expect(response.body.success).toBe(true);\n      expect(response.body.data.transactions).toHaveLength(2);\n    });\n\n    it('should filter transactions by type', async () => {\n      const response = await request(app)\n        .get('/api/transactions?type=income')\n        .set('Authorization', `Bearer ${authToken}`)\n        .expect(200);\n\n      expect(response.body.success).toBe(true);\n      expect(response.body.data.transactions.every(t => t.type === 'income')).toBe(true);\n    });\n\n    it('should calculate summary statistics', async () => {\n      const response = await request(app)\n        .get('/api/transactions')\n        .set('Authorization', `Bearer ${authToken}`)\n        .expect(200);\n\n      expect(response.body.success).toBe(true);\n      expect(response.body.data.summary).toBeDefined();\n      expect(response.body.data.summary.expense).toBeDefined();\n      expect(response.body.data.summary.income).toBeDefined();\n      expect(response.body.data.summary.expense.total).toBe(300.00);\n      expect(response.body.data.summary.income.total).toBe(1000.00);\n    });\n  });\n\n  describe('Authorization', () => {\n    it('should reject request without token', async () => {\n      const response = await request(app)\n        .post('/api/transactions')\n        .send({\n          categoryId,\n          type: 'expense',\n          amount: 50.00,\n          transactionDate: '2026-01-12'\n        })\n        .expect(401);\n\n      expect(response.body.error).toBe('Access denied. No token provided.');\n    });\n\n    it('should reject request with invalid token', async () => {\n      const response = await request(app)\n        .post('/api/transactions')\n        .set('Authorization', 'Bearer invalid-token')\n        .send({\n          categoryId,\n          type: 'expense',\n          amount: 50.00,\n          transactionDate: '2026-01-12'\n        })\n        .expect(401);\n\n      expect(response.body.error).toBe('Invalid token.');\n    });\n  });\n\n  describe('Rate limiting', () => {\n    it('should enforce rate limiting on auth endpoints', async () => {\n      const loginData = {\n        email: 'test@example.com',\n        password: 'wrong-password'\n      };\n\n      for (let i = 0; i < 6; i++) {\n        const response = await request(app)\n          .post('/api/auth/login')\n          .send(loginData);\n\n        if (i < 5) {\n          expect(response.status).toBe(401);\n        } else {\n          expect(response.status).toBe(429);\n          expect(response.body.error).toContain('Too many authentication attempts');\n        }\n      }\n    });\n  });\n});"
    },
    {
        "index": 41,
        "content": "// backend/tests/integration/api.test.js\nconst request = require('supertest');\nconst app = require('../../src/app');\nconst { sequelize } = require('../../src/models');\nconst bcrypt = require('bcrypt');\n\ndescribe('API Integration Tests', () => {\n  let authToken;\n  let userId;\n  let server;\n\n  beforeAll(async () => {\n    server = app.listen(0);\n    await sequelize.sync({ force: true });\n  });\n\n  afterAll(async () => {\n    await sequelize.close();\n    server.close();\n  });\n\n  describe('Complete user flow', () => {\n    it('should handle complete user registration and transaction flow', async () => {\n      const registerResponse = await request(app)\n        .post('/api/auth/register')\n        .send({\n          email: 'integration@test.com',\n          password: 'TestPassword123!',\n          firstName: 'Integration',\n          lastName: 'Test'\n        })\n        .expect(201);\n\n      expect(registerResponse.body.success).toBe(true);\n      expect(registerResponse.body.data.user.email).toBe('integration@test.com');\n\n      const loginResponse = await request(app)\n        .post('/api/auth/login')\n        .send({\n          email: 'integration@test.com',\n          password: 'TestPassword123!'\n        })\n        .expect(200);\n\n      expect(loginResponse.body.success).toBe(true);\n      expect(loginResponse.body.data.token).toBeDefined();\n      \n      authToken = loginResponse.body.data.token;\n      userId = loginResponse.body.data.user.id;\n\n      const categoriesResponse = await request(app)\n        .get('/api/categories')\n        .set('Authorization', `Bearer ${authToken}`)\n        .expect(200);\n\n      expect(categoriesResponse.body.success).toBe(true);\n      expect(categoriesResponse.body.data.length).toBeGreaterThan(0);\n\n      const categoryId = categoriesResponse.body.data[0].id;\n\n      const transactions = [\n        {\n          categoryId,\n          type: 'expense',\n          amount: 50.00,\n          description: 'Grocery shopping',\n          transactionDate: '2026-01-10'\n        },\n        {\n          categoryId,\n          type: 'expense',\n          amount: 30.00,\n          description: 'Lunch',\n          transactionDate: '2026-01-11'\n        },\n        {\n          categoryId,\n          type: 'income',\n          amount: 2000.00,\n          description: 'Salary',\n          transactionDate: '2026-01-12'\n        }\n      ];\n\n      for (const transaction of transactions) {\n        const response = await request(app)\n          .post('/api/transactions')\n          .set('Authorization', `Bearer ${authToken}`)\n          .send(transaction)\n          .expect(201);\n\n        expect(response.body.success).toBe(true);\n      }\n\n      const dashboardResponse = await request(app)\n        .get('/api/dashboard')\n        .set('Authorization', `Bearer ${authToken}`)\n        .expect(200);\n\n      expect(dashboardResponse.body.success).toBe(true);\n      expect(dashboardResponse.body.data.summary).toBeDefined();\n      expect(dashboardResponse.body.data.summary.totalExpenses).toBe(80.00);\n      expect(dashboardResponse.body.data.summary.totalIncome).toBe(2000.00);\n\n      const budgetResponse = await request(app)\n        .post('/api/budgets')\n        .set('Authorization', `Bearer ${authToken}`)\n        .send({\n          categoryId,\n          amount: 500.00,\n          period: 'monthly'\n        })\n        .expect(201);\n\n      expect(budgetResponse.body.success).toBe(true);\n\n      const budgetStatusResponse = await request(app)\n        .get('/api/budgets/status')\n        .set('Authorization', `Bearer ${authToken}`)\n        .expect(200);\n\n      expect(budgetStatusResponse.body.success).toBe(true);\n      expect(budgetStatusResponse.body.data[0].spent).toBe(80.00);\n      expect(budgetStatusResponse.body.data[0].budgeted).toBe(500.00);\n\n      const aiInsightsResponse = await request(app)\n        .get('/api/ai/insights')\n        .set('Authorization', `Bearer ${authToken}`)\n        .expect(200);\n\n      expect(aiInsightsResponse.body.success).toBe(true);\n      expect(aiInsightsResponse.body.data.insights).toBeDefined();\n      expect(aiInsightsResponse.body.data.insights.length).toBeGreaterThan(0);\n    });\n  });\n\n  describe('Concurrent operations', () => {\n    it('should handle concurrent transaction creation', async () => {\n      const promises = [];\n      for (let i = 0; i < 10; i++) {\n        promises.push(\n          request(app)\n            .post('/api/transactions')\n            .set('Authorization', `Bearer ${authToken}`)\n            .send({\n              categoryId: 1,\n              type: 'expense',\n              amount: 10.00 + i,\n              transactionDate: '2026-01-12'\n            })\n        );\n      }\n      const responses = await Promise.all(promises);\n      responses.forEach((response, index) => {\n        expect(response.status).toBe(201);\n        expect(response.body.success).toBe(true);\n        expect(response.body.data.amount).toBe(10.00 + index);\n      });\n    });\n  });\n\n  describe('Error handling', () => {\n    it('should handle database connection errors gracefully', async () => {\n      const originalQuery = sequelize.query;\n      sequelize.query = jest.fn().mockRejectedValue(new Error('Database connection failed'));\n      const response = await request(app)\n        .get('/api/transactions')\n        .set('Authorization', `Bearer ${authToken}`)\n        .expect(500);\n      expect(response.body.success).toBe(false);\n      expect(response.body.error).toBe('Internal Server Error');\n      sequelize.query = originalQuery;\n    });\n\n    it('should handle validation errors properly', async () => {\n      const response = await request(app)\n        .post('/api/transactions')\n        .set('Authorization', `Bearer ${authToken}`)\n        .send({\n          categoryId: 'invalid',\n          type: 'invalid-type',\n          amount: -100,\n          transactionDate: 'invalid-date'\n        })\n        .expect(400);\n      expect(response.body.success).toBe(false);\n      expect(response.body.errors).toBeDefined();\n      expect(response.body.errors.length).toBeGreaterThan(0);\n    });\n  });\n});"
    },
    {
        "index": 42,
        "content": "// backend/tests/performance/load.test.js\nconst autocannon = require('autocannon');\n\ndescribe('Performance Tests', () => {\n  const API_URL = 'http://localhost:3001';\n  const AUTH_TOKEN = 'your-test-token';\n\n  it('should handle high load on dashboard endpoint', async () => {\n    const result = await autocannon({\n      url: `${API_URL}/api/dashboard`,\n      connections: 100,\n      duration: 30,\n      headers: {\n        'Authorization': `Bearer ${AUTH_TOKEN}`\n      }\n    });\n    expect(result.errors).toBe(0);\n    expect(result.timeouts).toBe(0);\n    expect(result.requests.average).toBeGreaterThan(100);\n    expect(result.latency.average).toBeLessThan(100);\n  });\n\n  it('should handle high load on transaction creation', async () => {\n    const result = await autocannon({\n      url: `${API_URL}/api/transactions`,\n      connections: 50,\n      duration: 30,\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${AUTH_TOKEN}`\n      },\n      body: JSON.stringify({\n        categoryId: 1,\n        type: 'expense',\n        amount: 50.00,\n        transactionDate: '2026-01-12'\n      })\n    });\n    expect(result.errors).toBeLessThan(5);\n    expect(result.timeouts).toBe(0);\n    expect(result.requests.average).toBeGreaterThan(50);\n  });\n\n  it('should maintain performance under memory pressure', async () => {\n    const initialMemory = process.memoryUsage().heapUsed;\n    const largeTransactions = Array.from({ length: 1000 }, (_, i) => ({\n      categoryId: 1,\n      type: 'expense',\n      amount: Math.random() * 1000,\n      description: 'x'.repeat(500),\n      transactionDate: '2026-01-12',\n      tags: Array.from({ length: 10 }, () => 'tag-' + Math.random()),\n      metadata: {\n        largeData: 'x'.repeat(10000)\n      }\n    }));\n    const promises = largeTransactions.map(transaction =>\n      fetch(`${API_URL}/api/transactions`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${AUTH_TOKEN}`\n        },\n        body: JSON.stringify(transaction)\n      })\n    );\n    await Promise.all(promises);\n    if (global.gc) global.gc();\n    const finalMemory = process.memoryUsage().heapUsed;\n    const memoryIncrease = (finalMemory - initialMemory) / 1024 / 1024;\n    expect(memoryIncrease).toBeLessThan(100);\n  });\n});"
    },
    {
        "index": 43,
        "content": "-- database/migrations/001_create_initial_schema.sql\n-- Enable required extensions\nCREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";\nCREATE EXTENSION IF NOT EXISTS \"pg_stat_statements\";\nCREATE EXTENSION IF NOT EXISTS \"btree_gist\";\n\n-- Create users table\nCREATE TABLE users (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    email VARCHAR(255) UNIQUE NOT NULL,\n    password_hash VARCHAR(255) NOT NULL,\n    first_name VARCHAR(50) NOT NULL,\n    last_name VARCHAR(50) NOT NULL,\n    preferred_currency VARCHAR(3) DEFAULT 'USD',\n    is_email_verified BOOLEAN DEFAULT FALSE,\n    last_login_at TIMESTAMP,\n    is_active BOOLEAN DEFAULT TRUE,\n    two_factor_secret VARCHAR(255),\n    two_factor_enabled BOOLEAN DEFAULT FALSE,\n    subscription_plan VARCHAR(20) DEFAULT 'free',\n    subscription_ends_at TIMESTAMP,\n    reset_password_token VARCHAR(255),\n    reset_password_expires TIMESTAMP,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Create indexes for users\nCREATE UNIQUE INDEX idx_users_email ON users(email);\nCREATE INDEX idx_users_active ON users(is_active);\nCREATE INDEX idx_users_plan ON users(subscription_plan);\n\n-- Create categories table\nCREATE TABLE categories (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(100) NOT NULL,\n    emoji VARCHAR(10),\n    type VARCHAR(10) CHECK (type IN ('expense', 'income')),\n    user_id UUID REFERENCES users(id) ON DELETE CASCADE,\n    is_default BOOLEAN DEFAULT FALSE,\n    color VARCHAR(7),\n    icon VARCHAR(50),\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    UNIQUE(name, user_id)\n);\n\n-- Insert default categories\nINSERT INTO categories (name, emoji, type, is_default) VALUES\n('Groceries', 'ðŸ›’', 'expense', TRUE),\n('Utility Bills', 'ðŸ’¡', 'expense', TRUE),\n('Salary', 'ðŸ’¼', 'income', TRUE),\n('Personal Spending', 'ðŸ‘¤', 'expense', TRUE),\n('Clothing', 'ðŸ‘”', 'expense', TRUE),\n('Lifestyle Activities', 'ðŸŽ¯', 'expense', TRUE),\n('Dining Out', 'ðŸ½ï¸', 'expense', TRUE),\n('Entertainment', 'ðŸŽ¬', 'expense', TRUE),\n('Transportation', 'ðŸš—', 'expense', TRUE),\n('Healthcare', 'ðŸ¥', 'expense', TRUE),\n('Education', 'ðŸ“š', 'expense', TRUE),\n('Other', 'ðŸ“¦', 'expense', TRUE);\n\n-- Create transactions table\nCREATE TABLE transactions (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    category_id INTEGER NOT NULL REFERENCES categories(id),\n    type VARCHAR(10) CHECK (type IN ('expense', 'income')) NOT NULL,\n    amount DECIMAL(12,2) NOT NULL CHECK (amount > 0),\n    description TEXT,\n    transaction_date DATE NOT NULL,\n    receipt_image_url VARCHAR(500),\n    is_ocr_processed BOOLEAN DEFAULT FALSE,\n    ocr_confidence DECIMAL(3,2),\n    tags TEXT[],\n    is_recurring BOOLEAN DEFAULT FALSE,\n    recurring_pattern VARCHAR(20) CHECK (recurring_pattern IN ('daily', 'weekly', 'monthly', 'yearly')),\n    recurring_end_date DATE,\n    split_transactions JSONB DEFAULT '[]',\n    metadata JSONB DEFAULT '{}',\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Create indexes for transactions\nCREATE INDEX idx_transactions_user_date ON transactions(user_id, transaction_date DESC);\nCREATE INDEX idx_transactions_category ON transactions(category_id);\nCREATE INDEX idx_transactions_type ON transactions(type);\nCREATE INDEX idx_transactions_date ON transactions(transaction_date);\nCREATE INDEX idx_transactions_amount ON transactions(amount);\nCREATE INDEX idx_transactions_recurring ON transactions(is_recurring) WHERE is_recurring = TRUE;\n\n-- Create budgets table\nCREATE TABLE budgets (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    category_id INTEGER NOT NULL REFERENCES categories(id),\n    amount DECIMAL(12,2) NOT NULL CHECK (amount > 0),\n    period_type VARCHAR(20) DEFAULT 'monthly' CHECK (period_type IN ('weekly', 'monthly', 'yearly')),\n    start_date DATE NOT NULL,\n    end_date DATE,\n    alert_threshold DECIMAL(5,2) DEFAULT 75.00 CHECK (alert_threshold >= 0 AND alert_threshold <= 100),\n    is_active BOOLEAN DEFAULT TRUE,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    UNIQUE(user_id, category_id, start_date)\n);\n\n-- Create investments table\nCREATE TABLE investments (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    name VARCHAR(255) NOT NULL,\n    type VARCHAR(100) NOT NULL,\n    principal DECIMAL(12,2) NOT NULL CHECK (principal > 0),\n    purchase_date DATE,\n    current_value DECIMAL(12,2),\n    expected_return DECIMAL(5,2),\n    actual_return DECIMAL(5,2),\n    return_percentage DECIMAL(5,2) GENERATED ALWAYS AS (\n        CASE \n            WHEN current_value IS NOT NULL AND principal > 0 \n            THEN ROUND(((current_value - principal) / principal * 100)::numeric, 2)\n            ELSE NULL\n        END\n    ) STORED,\n    notes TEXT,\n    metadata JSONB DEFAULT '{}',\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Create AI insights table\nCREATE TABLE ai_insights (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    insight_type VARCHAR(50) NOT NULL,\n    title VARCHAR(255) NOT NULL,\n    description TEXT NOT NULL,\n    category_filter VARCHAR(100),\n    date_range_start DATE,\n    date_range_end DATE,\n    priority VARCHAR(20) DEFAULT 'medium' CHECK (priority IN ('low', 'medium', 'high')),\n    is_actionable BOOLEAN DEFAULT TRUE,\n    action_items JSONB DEFAULT '[]',\n    is_read BOOLEAN DEFAULT FALSE,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Create refresh tokens table\nCREATE TABLE refresh_tokens (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    token VARCHAR(500) NOT NULL UNIQUE,\n    expires_at TIMESTAMP NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Create audit log table\nCREATE TABLE audit_logs (\n    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n    user_id UUID REFERENCES users(id) ON DELETE SET NULL,\n    action VARCHAR(100) NOT NULL,\n    resource_type VARCHAR(50),\n    resource_id UUID,\n    old_values JSONB,\n    new_values JSONB,\n    ip_address INET,\n    user_agent TEXT,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Create function for updated_at trigger\nCREATE OR REPLACE FUNCTION update_updated_at_column()\nRETURNS TRIGGER AS $$\nBEGIN\n    NEW.updated_at = CURRENT_TIMESTAMP;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\n-- Create triggers for updated_at\nCREATE TRIGGER update_users_updated_at BEFORE UPDATE ON users FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();\nCREATE TRIGGER update_categories_updated_at BEFORE UPDATE ON categories FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();\nCREATE TRIGGER update_transactions_updated_at BEFORE UPDATE ON transactions FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();\nCREATE TRIGGER update_budgets_updated_at BEFORE UPDATE ON budgets FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();\nCREATE TRIGGER update_investments_updated_at BEFORE UPDATE ON investments FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();\n\n-- Create indexes for performance\nCREATE INDEX idx_users_email_lower ON users(LOWER(email));\nCREATE INDEX idx_transactions_created_at ON transactions(created_at DESC);\nCREATE INDEX idx_budgets_user_active ON budgets(user_id, is_active);\nCREATE INDEX idx_investments_user_type ON investments(user_id, type);\nCREATE INDEX idx_ai_insights_user_unread ON ai_insights(user_id, is_read);\nCREATE INDEX idx_audit_logs_user_action ON audit_logs(user_id, action);\nCREATE INDEX idx_audit_logs_created_at ON audit_logs(created_at DESC);\n\n-- Create composite indexes for common queries\nCREATE INDEX idx_transactions_user_category_date ON transactions(user_id, category_id, transaction_date DESC);\nCREATE INDEX idx_transactions_user_type_date ON transactions(user_id, type, transaction_date DESC);"
    },
    {
        "index": 44,
        "content": "#!/bin/bash\n# database/scripts/backup.sh\n\n# Configuration\nDB_NAME=\"expense_tracker_pro\"\nDB_USER=\"expense_user\"\nBACKUP_DIR=\"/backups/database\"\nS3_BUCKET=\"expense-tracker-backups\"\nRETENTION_DAYS=30\n\n# Create backup directory\nmkdir -p $BACKUP_DIR\n\n# Generate backup filename with timestamp\nTIMESTAMP=$(date +%Y%m%d_%H%M%S)\nBACKUP_FILE=\"${BACKUP_DIR}/${DB_NAME}_${TIMESTAMP}.sql.gz\"\n\n# Create database backup\necho \"Creating database backup...\"\npg_dump -h localhost -U $DB_USER -d $DB_NAME --verbose --clean --if-exists --create | gzip > $BACKUP_FILE\n\n# Check if backup was successful\nif [ $? -eq 0 ]; then\n    echo \"Backup created successfully: $BACKUP_FILE\"\n    echo \"Uploading to S3...\"\n    aws s3 cp $BACKUP_FILE s3://$S3_BUCKET/database/\n    if [ $? -eq 0 ]; then\n        echo \"Backup uploaded to S3 successfully\"\n        find $BACKUP_DIR -name \"*.sql.gz\" -mtime +7 -delete\n        echo \"Backup process completed successfully\"\n    else\n        echo \"Failed to upload backup to S3\"\n        exit 1\n    fi\nelse\n    echo \"Database backup failed\"\n    exit 1\nfi"
    },
    {
        "index": 45,
        "content": "# ai-engine/app.py\nfrom fastapi import FastAPI, File, UploadFile, HTTPException, Depends\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentials\nfrom pydantic import BaseModel\nimport pytesseract\nfrom PIL import Image\nimport io\nimport re\nimport cv2\nimport numpy as np\nfrom datetime import datetime\nimport logging\nfrom typing import Optional, Dict, Any\nimport torch\nfrom transformers import pipeline\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\napp = FastAPI(title=\"AI Expense Tracker Engine\", version=\"1.0.0\")\nsecurity = HTTPBearer()\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\nnlp_pipeline = pipeline(\"text-classification\", model=\"distilbert-base-uncased-finetuned-sst-2-english\")\n\nclass OCRResult(BaseModel):\n    success: bool\n    data: Dict[str, Any]\n    confidence: float\n    requires_confirmation: bool = True\n\nclass AIInsight(BaseModel):\n    type: str\n    title: str\n    description: str\n    priority: str = \"medium\"\n    actionable: bool = True\n    suggestions: list = []\n\ndef preprocess_image(image: Image.Image) -> Image.Image:\n    img_array = np.array(image)\n    if len(img_array.shape) == 3:\n        img_array = cv2.cvtColor(img_array, cv2.COLOR_RGB2GRAY)\n    _, binary = cv2.threshold(img_array, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)\n    denoised = cv2.fastNlMeansDenoising(binary)\n    return Image.fromarray(denoised)\n\ndef extract_amount(text: str) -> Optional[float]:\n    patterns = [r'\\$?\\s*(\\d+\\.\\d{2})', r'(?:Total|Amount).*?\\$?\\s*(\\d+\\.\\d{2})']\n    for pattern in patterns:\n        matches = re.findall(pattern, text, re.IGNORECASE)\n        if matches:\n            return float(matches[0])\n    return None\n\ndef predict_category(text: str) -> str:\n    keywords = {'grocery': 'groceries', 'restaurant': 'dining', 'gas': 'transportation'}\n    text_lower = text.lower()\n    for k, v in keywords.items():\n        if k in text_lower: return v\n    return 'other'\n\n@app.post(\"/extract-receipt\", response_model=OCRResult)\nasync def extract_receipt(file: UploadFile = File(...)):\n    contents = await file.read()\n    image = Image.open(io.BytesIO(contents))\n    text = pytesseract.image_to_string(preprocess_image(image))\n    amount = extract_amount(text)\n    category = predict_category(text)\n    return OCRResult(success=True, data={\"amount\": amount, \"category\": category}, confidence=0.7)"
    },
    {
        "index": 46,
        "content": "// mobile/app.json\n{\n  \"expo\": {\n    \"name\": \"AI Expense Tracker Pro\",\n    \"slug\": \"ai-expense-tracker-pro\",\n    \"version\": \"1.0.0\",\n    \"orientation\": \"portrait\",\n    \"icon\": \"./assets/icon.png\",\n    \"userInterfaceStyle\": \"automatic\",\n    \"splash\": {\n      \"image\": \"./assets/splash.png\",\n      \"resizeMode\": \"contain\",\n      \"backgroundColor\": \"#ffffff\"\n    },\n    \"updates\": { \"fallbackToCacheTimeout\": 0 },\n    \"assetBundlePatterns\": [ \"**/*\" ],\n    \"ios\": {\n      \"supportsTablet\": true,\n      \"bundleIdentifier\": \"com.aiexpensetracker.pro\",\n      \"infoPlist\": {\n        \"NSCameraUsageDescription\": \"This app uses the camera to scan receipts.\"\n      }\n    },\n    \"android\": {\n      \"package\": \"com.aiexpensetracker.pro\",\n      \"permissions\": [ \"CAMERA\", \"READ_EXTERNAL_STORAGE\", \"WRITE_EXTERNAL_STORAGE\" ]\n    }\n  }\n}"
    },
    {
        "index": 47,
        "content": "// mobile/App.js\nimport React, { useState, useEffect } from 'react';\nimport { NavigationContainer } from '@react-navigation/native';\nimport { Provider } from 'react-redux';\nimport { PersistGate } from 'redux-persist/integration/react';\nimport { store, persistor } from './src/store';\nimport { AuthProvider, useAuth } from './src/contexts/AuthContext';\nimport { ThemeProvider } from './src/contexts/ThemeContext';\nimport { LoadingScreen } from './src/components/UI/LoadingScreen';\nimport { AuthNavigator } from './src/navigation/AuthNavigator';\nimport { MainNavigator } from './src/navigation/MainNavigator';\n\nexport default function App() {\n  return (\n    <Provider store={store}>\n      <PersistGate loading={<LoadingScreen />} persistor={persistor}>\n        <ThemeProvider>\n          <AuthProvider>\n            <NavigationContainer>\n              <AppNavigator />\n            </NavigationContainer>\n          </AuthProvider>\n        </ThemeProvider>\n      </PersistGate>\n    </Provider>\n  );\n}\n\nfunction AppNavigator() {\n  const { user, isLoading } = useAuth();\n  if (isLoading) return <LoadingScreen />;\n  return user ? <MainNavigator /> : <AuthNavigator />;\n}"
    },
    {
        "index": 48,
        "content": "// mobile/src/screens/DashboardScreen.js\nimport React, { useState, useCallback } from 'react';\nimport { View, ScrollView, StyleSheet, RefreshControl } from 'react-native';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { fetchDashboardData } from '../store/slices/dashboardSlice';\nimport { SummaryCards, AIInsightsPanel, ExpenseChart, BudgetOverview, RecentTransactions } from '../components';\nimport { colors, spacing } from '../theme';\n\nexport const DashboardScreen = ({ navigation }) => {\n  const dispatch = useDispatch();\n  const { data, loading } = useSelector(state => state.dashboard);\n  const [refreshing, setRefreshing] = useState(false);\n\n  const loadData = useCallback(async () => {\n    await dispatch(fetchDashboardData()).unwrap();\n  }, [dispatch]);\n\n  const onRefresh = async () => {\n    setRefreshing(true);\n    await loadData();\n    setRefreshing(false);\n  };\n\n  return (\n    <ScrollView \n      style={styles.container}\n      refreshControl={<RefreshControl refreshing={refreshing} onRefresh={onRefresh} />}\n    >\n      <View style={styles.content}>\n        <SummaryCards data={data?.summary} />\n        <AIInsightsPanel insights={data?.aiInsights} />\n        <ExpenseChart data={data?.expenseBreakdown} />\n        <BudgetOverview budgets={data?.budgetStatus} />\n        <RecentTransactions transactions={data?.recentTransactions} />\n      </View>\n    </ScrollView>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: { flex: 1, backgroundColor: colors.background },\n  content: { padding: spacing.md }\n});"
    },
    {
        "index": 49,
        "content": "# backend/Dockerfile\nFROM node:18-alpine AS builder\nRUN apk add --no-cache python3 make g++\nWORKDIR /app\nCOPY package*.json ./\nRUN npm ci --only=production\n\nFROM node:18-alpine\nWORKDIR /app\nCOPY --from=builder /app/node_modules ./node_modules\nCOPY . .\nUSER 1001\nEXPOSE 3001\nCMD [\"node\", \"src/index.js\"]"
    }
]
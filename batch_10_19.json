[
    {
        "index": 10,
        "content": "# ai_engine/app.py\nfrom fastapi import FastAPI, File, UploadFile, HTTPException\nfrom fastapi.middleware.cors import CORSMiddleware\nimport pytesseract\nfrom PIL import Image\nimport io\nimport re\nfrom datetime import datetime\n\napp = FastAPI(title=\"AI Expense Tracker Engine\")\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n@app.post(\"/extract-receipt\")\nasync def extract_receipt(file: UploadFile = File(...)):\n    try:\n        contents = await file.read()\n        image = Image.open(io.BytesIO(contents))\n        \n        # OCR processing\n        text = pytesseract.image_to_string(image)\n        \n        # Extract data using regex patterns\n        extracted = {\n            \"amount\": extract_amount(text),\n            \"date\": extract_date(text),\n            \"merchant\": extract_merchant(text),\n            \"category\": predict_category(text),\n            \"raw_text\": text\n        }\n        \n        return {\n            \"success\": True,\n            \"data\": extracted,\n            \"requires_confirmation\": True\n        }\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\ndef extract_amount(text: str) -> float:\n    # Pattern: $##.## or ##.## USD etc.\n    patterns = [\n        r'\\$?(\\d+\\.\\d{2})',\n        r'(\\d+\\.\\d{2})\\s*(?:USD|BDT|EUR)'\n    ]\n    for pattern in patterns:\n        match = re.search(pattern, text)\n        if match:\n            return float(match.group(1))\n    return 0.0\n\ndef extract_date(text: str) -> str:\n    patterns = [\n        r'(\\d{1,2}[/-]\\d{1,2}[/-]\\d{4})',\n        r'(\\d{4}[/-]\\d{1,2}[/-]\\d{1,2})'\n    ]\n    for pattern in patterns:\n        match = re.search(pattern, text)\n        if match:\n            return match.group(1)\n    return datetime.now().strftime(\"%Y-%m-%d\")\n\ndef extract_merchant(text: str) -> str:\n    # Simple heuristic: first non-empty line\n    lines = [line.strip() for line in text.split('\\n') if line.strip()]\n    return lines[0] if lines else \"Unknown\"\n\ndef predict_category(text: str) -> str:\n    # Simple keyword-based classification\n    text_lower = text.lower()\n    if any(word in text_lower for word in ['grocery', 'supermarket', 'food']):\n        return 'Groceries'\n    elif any(word in text_lower for word in ['gas', 'fuel', 'transport']):\n        return 'Transportation'\n    elif any(word in text_lower for word in ['restaurant', 'cafe', 'dining']):\n        return 'Dining Out'\n    return 'Other'"
    },
    {
        "index": 11,
        "content": "# ai_engine/services/insight_generator.py\nimport pandas as pd\nfrom typing import List, Dict, Any\nfrom datetime import datetime, timedelta\n\nclass AIInsightGenerator:\n    def __init__(self, db_connection):\n        self.db = db_connection\n    \n    def generate_insights(self, user_id: str, date_range_start: str, date_range_end: str) -> List[Dict]:\n        insights = []\n        \n        # Fetch user transactions\n        query = \"\"\"\n            SELECT t.*, c.name as category_name, c.emoji\n            FROM transactions t\n            JOIN categories c ON t.category_id = c.id\n            WHERE t.user_id = %s \n            AND t.transaction_date BETWEEN %s AND %s\n        \"\"\"\n        df = pd.read_sql(query, self.db, params=[user_id, date_range_start, date_range_end])\n        \n        if df.empty:\n            return insights\n        \n        # Insight 1: Spending pattern analysis\n        insights.append(self._analyze_spending_patterns(df))\n        \n        # Insight 2: Budget adherence\n        insights.append(self._analyze_budget_adherence(user_id, df, date_range_start, date_range_end))\n        \n        # Insight 3: Investment opportunities\n        insights.append(self._analyze_savings_opportunities(df))\n        \n        return [i for i in insights if i is not None]\n    \n    def _analyze_spending_patterns(self, df: pd.DataFrame) -> Dict:\n        expense_df = df[df['type'] == 'expense']\n        if expense_df.empty:\n            return None\n        \n        category_spending = expense_df.groupby('category_name')['amount'].sum().sort_values(ascending=False)\n        top_category = category_spending.index[0]\n        top_amount = category_spending.iloc[0]\n        total_spent = expense_df['amount'].sum()\n        \n        return {\n            \"type\": \"spending_pattern\",\n            \"title\": \"Top Spending Category\",\n            \"description\": f\"You spent ${top_amount:.2f} on {top_category}, representing { (top_amount / total_spent * 100):.1f }% of total expenses.\",\n            \"actionable\": True,\n            \"suggestion\": f\"Consider reducing {top_category} spending by 10-15% to save ${top_amount * 0.15:.2f} monthly.\"\n        }\n    \n    def _analyze_budget_adherence(self, user_id: str, df: pd.DataFrame, start_date: str, end_date: str) -> Dict:\n        # Implementation for budget vs actual analysis\n        # This would query budget table and compare with actual spending\n        pass"
    },
    {
        "index": 12,
        "content": "// tests/unit/transactionController.test.js\nconst request = require('supertest');\nconst app = require('../src/app');\nconst { Transaction, Category, User } = require('../src/models');\nconst bcrypt = require('bcrypt');\n\ndescribe('Transaction Controller', () => {\n    let token;\n    let userId;\n    let categoryId;\n\n    beforeAll(async () => {\n        # Create test user\n        const hashedPassword = await bcrypt.hash('test123', 10);\n        const user = await User.create({\n            email: 'test@example.com',\n            password_hash: hashedPassword,\n            full_name: 'Test User'\n        });\n        userId = user.id;\n\n        # Create test category\n        const category = await Category.create({\n            name: 'Test Groceries',\n            emoji: 'ðŸ›’',\n            type: 'expense',\n            user_id: userId\n        });\n        categoryId = category.id;\n\n        // Login to get token\n        const res = await request(app)\n            .post('/api/auth/login')\n            .send({ email: 'test@example.com', password: 'test123' });\n        \n        token = res.body.token;\n    });\n\n    afterAll(async () => {\n        await Transaction.destroy({ where: { user_id: userId } });\n        await Category.destroy({ where: { id: categoryId } });\n        await User.destroy({ where: { id: userId } });\n    });\n\n    describe('POST /api/transactions', () => {\n        it('should create a new transaction', async () => {\n            const res = await request(app)\n                .post('/api/transactions')\n                .set('Authorization', `Bearer ${token}`)\n                .send({\n                    categoryId: categoryId,\n                    type: 'expense',\n                    amount: 99.99,\n                    description: 'Test grocery purchase',\n                    transactionDate: '2026-01-12'\n                });\n\n            expect(res.statusCode).toBe(201);\n            expect(res.body.data.amount).toBe(99.99);\n            expect(res.body.data.description).toBe('Test grocery purchase');\n        });\n\n        it('should reject invalid category', async () => {\n            const res = await request(app)\n                .post('/api/transactions')\n                .set('Authorization', `Bearer ${token}`)\n                .send({\n                    categoryId: 99999, // Non-existent\n                    type: 'expense',\n                    amount: 50.00\n                });\n\n            expect(res.statusCode).toBe(400);\n            expect(res.body.error).toContain('Invalid category');\n        });\n    });\n\n    describe('GET /api/transactions', () => {\n        it('should fetch transactions with filters', async () => {\n            const res = await request(app)\n                .get('/api/transactions?startDate=2026-01-01&endDate=2026-01-31')\n                .set('Authorization', `Bearer ${token}`);\n\n            expect(res.statusCode).toBe(200);\n            expect(res.body.data).toBeInstanceOf(Array);\n        });\n    });\n});"
    },
    {
        "index": 13,
        "content": "// __tests__/DashboardFilters.test.js\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport DashboardFilters from '@/components/Dashboard/DashboardFilters';\nimport { useTransactions } from '@/hooks/useTransactions';\n\njest.mock('@/hooks/useTransactions');\n\ndescribe('DashboardFilters', () => {\n    const mockOnFilterChange = jest.fn();\n    \n    beforeEach(() => {\n        useTransactions.mockReturnValue({\n            categories: [\n                { id: 1, name: 'Groceries', emoji: 'ðŸ›’' },\n                { id: 2, name: 'Transportation', emoji: 'ðŸš—' }\n            ]\n        });\n    });\n\n    it('applies date and category filters', async () => {\n        render(<DashboardFilters onFilterChange={mockOnFilterChange} />);\n        \n        // Select a category\n        const categorySelect = screen.getByRole('listbox');\n        fireEvent.click(categorySelect);\n        fireEvent.click(screen.getByText('ðŸ›’ Groceries'));\n        \n        // Click apply\n        fireEvent.click(screen.getByText('Apply Filters'));\n        \n        await waitFor(() => {\n            expect(mockOnFilterChange).toHaveBeenCalledWith(\n                expect.objectContaining({\n                    categories: ['1']\n                })\n            );\n        });\n    });\n});"
    },
    {
        "index": 14,
        "content": "# docker-compose.prod.yml\nversion: '3.8'\n\nservices:\n  # PostgreSQL Database\n  postgres:\n    image: postgres:15-alpine\n    environment:\n      POSTGRES_DB: expensetracker\n      POSTGRES_USER: ${DB_USER}\n      POSTGRES_PASSWORD: ${DB_PASSWORD}\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n      - ./init.sql:/docker-entrypoint-initdb.d/init.sql\n    ports:\n      - \"5432:5432\"\n    healthcheck:\n      test: [\"CMD-SHELL\", \"pg_isready -U ${DB_USER}\"]\n      interval: 10s\n      timeout: 5s\n      retries: 5\n\n  # Redis Cache\n  redis:\n    image: redis:7-alpine\n    ports:\n      - \"6379:6379\"\n\n  # Backend API\n  backend:\n    build:\n      context: ./backend\n      dockerfile: Dockerfile\n    environment:\n      NODE_ENV: production\n      DB_HOST: postgres\n      DB_USER: ${DB_USER}\n      DB_PASSWORD: ${DB_PASSWORD}\n      DB_NAME: expensetracker\n      JWT_SECRET: ${JWT_SECRET}\n      REDIS_URL: redis://redis:6379\n    depends_on:\n      postgres:\n        condition: service_healthy\n    ports:\n      - \"3001:3001\"\n\n  # AI Engine\n  ai-engine:\n    build:\n      context: ./ai_engine\n      dockerfile: Dockerfile\n    environment:\n      TESSERACT_PATH: /usr/bin/tesseract\n    volumes:\n      - ./ai_engine:/app\n    ports:\n      - \"8000:8000\"\n\n  # Frontend\n  frontend:\n    build:\n      context: ./frontend\n      dockerfile: Dockerfile\n    environment:\n      NEXT_PUBLIC_API_URL: ${API_URL}\n    ports:\n      - \"3000:3000\"\n\nvolumes:\n  postgres_data:"
    },
    {
        "index": 15,
        "content": "# .github/workflows/ci.yml\nname: CI/CD Pipeline\n\non:\n  push:\n    branches: [ main, develop ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  test-backend:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      \n      - name: Setup Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: '18'\n          cache: 'npm'\n          cache-dependency-path: backend/package-lock.json\n      \n      - name: Install dependencies\n        run: cd backend && npm ci\n      \n      - name: Run linter\n        run: cd backend && npm run lint\n      \n      - name: Run unit tests\n        run: cd backend && npm run test:ci\n        env:\n          NODE_ENV: test\n          DB_HOST: localhost\n      \n      - name: Run integration tests\n        run: cd backend && npm run test:integration\n\n  test-android:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      \n      - name: Setup JDK\n        uses: actions/setup-java@v3\n        with:\n          distribution: 'temurin'\n          java-version: '17'\n      \n      - name: Run Android unit tests\n        run: cd android && ./gradlew test"
    },
    {
        "index": 16,
        "content": "// frontend/hooks/useTempData.js\nimport { create } from 'zustand';\n\n// Store for temporary OCR/Voice data\nexport const useTempDataStore = create((set) => ({\n    pendingTransaction: null,\n    setPendingTransaction: (data) => set({ pendingTransaction: data }),\n    clearPendingTransaction: () => set({ pendingTransaction: null })\n}));\n\n// In TransactionForm component\nimport { useTempDataStore } from '@/hooks/useTempData';\n\nfunction TransactionForm() {\n    const pendingData = useTempDataStore(state => state.pendingTransaction);\n    const clearPendingData = useTempDataStore(state => state.clearPendingTransaction);\n    \n    useEffect(() => {\n        if (pendingData) {\n            // Prefill form with OCR/Voice data\n            setFormData(pendingData);\n            // Keep data even on refresh using localStorage\n            localStorage.setItem('pending_transaction', JSON.stringify(pendingData));\n            clearPendingData();\n        }\n    }, [pendingData]);\n    \n    // On mount, check localStorage\n    useEffect(() => {\n        const saved = localStorage.getItem('pending_transaction');\n        if (saved) {\n            setFormData(JSON.parse(saved));\n        }\n    }, []);\n}"
    },
    {
        "index": 17,
        "content": "// backend/middleware/cache.js\nconst redis = require('redis');\nconst client = redis.createClient();\n\nclient.on('error', (err) => console.error('Redis Error:', err));\n\nconst cacheMiddleware = (duration) => async (req, res, next) => {\n    const key = `__expres__${req.originalUrl}`;\n\n    try {\n        const cached = await client.get(key);\n        if (cached) {\n            return res.json(JSON.parse(cached));\n        }\n\n        // Override res.json to cache response\n        const originalJson = res.json.bind(res);\n        res.json = (body) => {\n            client.setEx(key, duration, JSON.stringify(body));\n            return originalJson(body);\n        };\n\n        next();\n    } catch (error) {\n        next();\n    }\n};\n\nmodule.exports = cacheMiddleware;\n\n// Apply in routes\napp.get('/api/dashboard/summary', \n    authenticate, \n    cacheMiddleware(300), // 5 minutes cache\n    dashboardController.getSummary\n);"
    },
    {
        "index": 18,
        "content": "// backend/middleware/auth.js\nconst jwt = require('jsonwebtoken');\nconst { User } = require('../models');\n\nexports.authenticate = async (req, res, next) => {\n    try {\n        const token = req.header('Authorization')?.replace('Bearer ', '');\n        \n        if (!token) {\n            return res.status(401).json({ error: 'Access denied. No token provided.' });\n        }\n\n        const decoded = jwt.verify(token, process.env.JWT_SECRET);\n        const user = await User.findByPk(decoded.id);\n        \n        if (!user) {\n            return res.status(401).json({ error: 'Invalid token.' });\n        }\n\n        req.user = user;\n        next();\n    } catch (error) {\n        res.status(401).json({ error: 'Invalid token.' });\n    }\n};\n\n// Password encryption\nconst bcrypt = require('bcrypt');\nexports.hashPassword = async (password) => {\n    const salt = await bcrypt.genSalt(12);\n    return await bcrypt.hash(password, salt);\n};"
    },
    {
        "index": 19,
        "content": "// backend/utils/encryption.js\nconst crypto = require('crypto');\n\nconst algorithm = 'aes-256-gcm';\nconst key = crypto.scryptSync(process.env.ENCRYPTION_KEY, 'salt', 32);\n\nexports.encrypt = (text) => {\n    const iv = crypto.randomBytes(16);\n    const cipher = crypto.createCipher(algorithm, key, iv);\n    let encrypted = cipher.update(text, 'utf8', 'hex');\n    encrypted += cipher.final('hex');\n    return iv.toString('hex') + ':' + encrypted;\n};\n\nexports.decrypt = (encryptedText) => {\n    const [ivHex, encrypted] = encryptedText.split(':');\n    const iv = Buffer.from(ivHex, 'hex');\n    const decipher = crypto.createDecipher(algorithm, key, iv);\n    let decrypted = decipher.update(encrypted, 'hex', 'utf8');\n    decrypted += decipher.final('utf8');\n    return decrypted;\n};"
    }
]